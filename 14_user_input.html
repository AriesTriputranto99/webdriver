<section>
  <h2>User Input</h2>
  <p>The WebDriver API offers two ways of interacting with elements,
  either with a set of low-level "do as I say" commands, or a
  high-level "do as I mean" set of commands. The former are offered to
  allow precise emulation of user input. The latter are offered as a
  convenience to cover the common case, and can conceivably be
  implemented on top of the lower level primitive operations.</p>

  <section>
    <h2 id="interactable">Interactable elements</h2>
    <p>Some input actions require the element to be interactable. The following conditions must be met for the element to be considered interactable:
    <ul>
      <li>The element MUST be visible, as defined in <a href="#determining-visibility">section 10.1</a>.</li>
      <li>The element MUST NOT be disabled:
      <ul>
        <li>If the currently loaded document being treated as an HTML
        4 document, the element is considered disabled if it does not support
        the <a href="http://www.w3.org/TR/html401/interact/forms.html#adef-disabled">disabled</a>
        attribute (according to the [[!HTML401]] spec), or the
        disabled attribute is not set in the case where that attribute.</li>
        <li>If the currently loaded document is an HTML 5 document,
          the element is
          not <a href="http://www.w3.org/TR/html401/interact/forms.html#adef-disabled">disabled</a>
          as defined in the [[!HTML5]] spec.</li>
      </ul>
      </li>
    </ul>
    </section>

    <section>
      <h2>Low Level Commands</h2>
      <p>The low level commands provide a mechanism for precisely stating how a user can interact with the browser. 

    <p>User input SHOULD be emulated natively, with the input events
    being indistinguishable from those generated by a real user
    interacting with the browser. It is therefore recommended that
    input events SHOULD NOT be generated at the DOM level using the
    "<a href="http://www.w3.org/TR/dom/#dom-document-createevent">createEvent</a>"
    API from [[!DOM4]] or similar. Instead, emulated input events
    SHOULD originate from the browser's own event queue. This is the
    order of preference for methods to emulate user input:</p>

    <ul>
      <li>Injection into the browser's event queue.</li>
      <li>Sending OS-specific input messages to the browser's window. This has the disadvantage that the browser being automated may not be properly isolated from a user accidentally modifying input device state.</li>
      <li>Use of Javascript to inject events at the DOM level.</li>
      <li>Use of the accessibility API. The disadvantage of this method is that the browser's window must be focused. As a result, multiple tests cannot run in parallel.</li>
    </ul>

      <p>TODO: Describe the commands for basic control of keyboard and mouse.</p>
      <section>
        <h2>Mouse</h2>
        <p>TODO: Ensure that this section mentions that mouse state MUST be maintained if the page is not related and MAY be maintained if the browser navigates to a new page.</p>
        <p>TODO: Handle the case where the browser is on a mouse-less device (eg. mobile phone)
      </section>
      <section>
        <h2>Keyboard</h2>
        <p></p>
        <section>
          <h2>IME</h2>
          <p></p>
        </section>
      </section>
      <section>
        <h2>Touch</h2>
        <p>TODO: Define capability to capture the concept that a browser supports touch events</p>
      </section>
    </section> <!-- low-level wire protocol commands -->

    <section>
    <h2>High Level Commands</h2>
    <p>These higher level commands SHOULD be built on top of the low level commands, and implement a user friendly way of interacting with a page in a way that models common user expectations.

    <section>
    <h2>Clicking</h2>
    <dl class="idl" title="partial interface WebElement">
      <dt>void click()</dt>
      <dd>Click in the middle of the <code>WebElement</code> instance. The middle of the element is defined as the middle of the box returned by
      calling <a
        href="http://www.w3.org/TR/cssom-view/#the-getclientrects-and-getboundingclientrect-methods">getBoundingClientRect</a>
      on the underlying DOM Element, according to the [[!CSSOM-VIEW]] spec. If
      the element is outside the <a
        href="http://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
      (according to the [[!CSS21]] spec), the implementation SHOULD bring the
      element into view first. The implementation MAY invoke scrollIntoView on
      the underlying DOM Element. The element MUST be visible, as defined in <a
        href="#determining-visibility">section 10.1</a>. See the note below for when the element is obscured by another element.
      Exceptions:
      <ul>
        <li>Links (A elements): Clicking happens in the middle of the first
        <a href="#determining-visibility">visible</a> bounding client rectangle. This is to overcome overflowing links where the middle of the bounding client rectangle does not actually fall on a clickable part of the link.</li>
        <li>SELECT elements without the &quot;multiple&quot; attribute set.
        Clicking on the select element SHOULD open the drop down menu. The next
        click, on any element, MUST close this menu.</li>
        <li>Clicking directly on an OPTION element (without clicking on the
        parent SELECT element previously) MUST open a selection menu, as if the
        SELECT option was clicked first, then click on the OPTION before finally
        closing the SELECT element's menu. The the SELECT menu MUST be closed
        once the action is complete.</li>
      </ul>
      <p>The possible errors for this command:
      <ul>
        <li>StaleElementReference if the given element is no longer attached to the DOM.</li>
        <li>ElementNotVisible if the element is hidden and thus cannot be interacted with.</li>
        <li>MoveTargetOutOfBounds if the element cannot be scrolled into view.</li>
      </ul>
      <p>This command MUST use either the mouse or touch mechanisms for
      emulating the user input. In the case where the browser being automated
      supports only mouse input or both mouse and touch input, the low-level
      mouse mechanisms MUST be used. If the browser only supports touch input,
      the low level touch inputs MUST be used.</p>
      </dd>
    </dl>
    <p class="note">As the goal is to emulate users as closely as possible, the
    implementation SHOULD NOT allow clicking on elements that are obscured by
    other elements. If the implementation forbids clicking on obscured elements,
    an <code>ElementNotVisible</code> exception MUST be thrown and this SHOULD have an
    explantory message explaining the reason. The implementation SHOULD try to
    scroll the element into view, but in case it is fully obscured, it SHOULD
    NOT be clickable.</p>
    </section>
    <section>
    <h2>Typing keys</h2>
    <p>A requirement for key-based interaction with an element is that it is
    <a href="#interactable">interactable</a>. Typing into an element is permitted if one of the following conditions is met:
    <ul>
      <li>The element is <a href="http://dev.w3.org/html5/spec/editing.html#focus">focusable</a> as defined in the editing section of the [[!HTML5]] spec.</li>
      <li>The element is allowed to be the <code>activeElement</code>. In
      addition to focusable elements, this allows typing to the <code>BODY</code> element.</li>
      <li>In an HTML5 document, the element is <a href="http://dev.w3.org/html5/spec/editing.html#attr-contenteditable">editable</a> as a result of having its <code>contentEditable</code> attribute set or the containing document is in <code>designMode</code>.</li>
      <li>The underlying browser implementation would allow keyboard input to
      directed to the element (eg. an HTML 4 document with a DIV marked as being
      contentEditable)</li>
    </ul>
    <p>Prior to any keyboard interaction, an attempt to shift focus to the
    element MUST be attempted if the element does not currently have the focus. This is the case if one of the following
    holds:
    <ul>
      <li>The element is not <code>document.activeElement</code></li>
      <li>The owner document of the element to be interacted with is not the
      focused document.</li>
    </ul>
    <p>In case focusing is needed, the implementation MUST follow the <a href="http://dev.w3.org/html5/spec/editing.html#focus-management"><b>focusing steps</b></a> as described in the focus management section of the [[!HTML5]] spec. The focus MUST NOT leave the element at the end of the interaction, other than as a result of the interaction itself (i.e. when the tab key is sent).
    </p>
    <dl class="idl" title="partial interface WebElement">
      <dt>void clear()</dt>
      <dd>Clears the value of the element.</dd>
      <dt>void sendKeys(string[] keysToSend)</dt>
      <dd>Sends a sequence of keyboard events representing the keys in the keysToSend parameter.
      <p>Caret positioning: If focusing was needed, after following the focusing steps, the caret MUST be positioned at the end of the text currently in the element. At the end of the interaction, the caret MUST be positioned at the end of the typed text sequence, unless the keys sent position it otherwise (e.g. using the LEFT key).</p>
      <p>There are four different types of keys that are emulated:
      <ul>
        <li>Character literals - lower-case symbols.</li>
        <li>Uppercase letters and symbols requiring the SHIFT key for typing.</li>
        <li>Modifier keys</li>
        <li>Special keys</li>
      </ul>The rest of this section details the values used to represent the different keys, as well as the expected behaviour for each key type.</dd>
    </dl>
    <p>When emulating user input, the implementation MUST generate
    the same sequence of events that would have been produced if a real user was
    sitting in front of the keyboard and typing the sequence of characters. In
    cases where there is more than one way to type this sequence, the
    implementation MUST choose one of the valid ways. For example, typing <code>AB</code> may be achieved by:
    <ul>
      <li>Holding down the Shift key</li>
      <li>Pressing the letter 'a'</li>
      <li>Pressing the letter 'b'</li>
      <li>Releasing the Shift key</li>
    </ul>
    Alternatively, it can be achieved by:
    <ul>
      <li>Holding down the Shift key</li>
      <li>Pressing the letter 'a'</li>
      <li>Releasing the Shift key</li>
      <li>Holding down the Shift key</li>
      <li>Pressing the letter 'b'</li>
      <li>Releasing the Shift key</li>
    </ul>
    <p>Or by simply turning on the CAPS LOCK first.</p>
    <p>
    The implementation MAY use the following algorithm to generate the events.
    If the implementation is using a different algorithm, it MUST adhere to the
    requirements listed below.
    <p>For each key, <var>key</var> in <var>keysToSend</var>, do
    <ol>
      <li>If <var>key</var> is a lower-case symbol:
      <ol>
        <li>If the Shift key is not pressed:
        <ol>
          <li>Generate a sequence of key-down, key-press and key-up events with
          <var>key</var> as
          the character to emulate</li>
        </ol>
        </li>
        <li>else (The Shift key is pressed)
        <ol>
          <li>let <var>uppercaseKey</var> be the upper-case character matching
          <var>key</var></li>
          <li>Generate a sequence of key-down, key-press and key-up events with
          <var>uppercaseKey</var> as the character to emulate</li>
        </ol>
        </li>
      </ol>
      </li>
      <li>Else if <var>key</var> is an upper-case symbol:
      <ol>
        <li>If the Shift key is not pressed:
        <ol>
          <li>Generate a key-down event of the Shift key.
          <li>Generate a sequence of key-down, key-press and key-up events with
          <var>key</var> as
          the character to emulate</li>
          <li>Generate a key-up event of the Shift key.
        </ol>
        </li>
        <li>else (The Shift key is pressed)
        <ol>
          <li>Generate a sequence of key-down, key-press and key-up events with
          <var>key</var> as the character to emulate</li>
        </ol>
        </li>
      </ol>
      </li>
      <li>Else if <var>key</var> represents a modifier key:
      <ol>
        <li>let <var>modifier</var> be the modifier key represented by
        <var>key</var></li>
        <li>If <var>modifier</var> is currently held down:
        <ol><li>Generate a key-up event of <var>modifier</var></li></ol>
        </li>
        <li>Else:
        <ol><li>Generate a key-down event of <var>modifier</var></li></ol>
        </li>
        <li>Maintain this key state and use it to modify the input until it is
        pressed again.</li>
      </ol>
      </li>
      <li>Else if <var>key</var> represents the NULL key:
      <ol>
        <li>Generate key-up events of all modifier keys currently held
        down.</li>
        <li>All modifier keys are now assumed to be released.</li>
      </ol>
      </li>
      <li>Else if <var>key</var> represents a special key:
      <ol>
        <li>Translate <var>key</var> to the special key it represents</li>
        <li>Generate a sequence of key-down, key-press and key-up events for the special key.</li>
      </ol>
      </li>
    </ol>
    <p>Once keyboard input is complete, an implicit <var>NULL</var> key is sent unless the
    final character is the <var>NULL</var> key.</p>
    <p> <!-- Pseudo-code --></p>
    <p>Any implementation MUST comply with these requirements:
    <ul>
      <li>For uppercase letters and symbols that require the Shift key to be
      pressed, there are two options:
      <ul>
        <li>A single Shift key-down event is generated before the entire
        sequence of uppercase letters.</li>
        <li>Before each such letter or symbol, a Shift key-down event is
        generated. After each letter or symbol, a Shift key-up event is
        generated.</li>
      </ul></li>
      <li>A user-specified Shift press implies capitalization of all following
      characters.</li>
      <li>If a user-specified Shift press precedes uppercase letters and
      symbols, a second Shift key-down event MUST NOT be generated. In that
      case, a Shift key-up event MUST NOT be generated implicitly by the
      implementation.</li>
      <li>The <var>NULL</var> key releases all currently held down modifier keys.</li>
      <li>The state of all modifier keys must be reset at the end of each
      <code>sendKeys</code> call and the appropriate key-up events
      generated</li>
    </ul>
    <p> <!-- Algorithm paragraph --></p>
    <h3>Character types</h3>
    <p>The <var>keysToSend</var> parameter contains a mix of printable
    characters and pressable keys that aren't text. Pressable keys that aren't
    text are stored in the Unicode PUA (Private Use Area) code points,
    0xE000-0xF8FF. The following table describes the mapping between PUA and
    key:
    <table class="simple">
      <tr>
        <th>Key</th>
        <th>Code</th>
        <th>Type</th>
      </tr>
      <tr><td>NULL</td><td>\uE000</td><td>NULL</td></tr>
      <tr><td>CANCEL</td><td>\uE001</td><td>Special key</td></tr>
      <tr><td>HELP</td><td>\uE002</td><td>Special key</td></tr>
      <tr><td>BACK_SPACE</td><td>\uE003</td><td>Special key</td></tr>
      <tr><td>TAB</td><td>\uE004</td><td>Special key</td></tr>
      <tr><td>CLEAR</td><td>\uE005</td><td>Special key</td></tr>
      <tr><td>RETURN</td><td>\uE006</td><td>Special key</td></tr>
      <tr><td>ENTER</td><td>\uE007</td><td>Special key</td></tr>
      <tr><td>SHIFT</td><td>\uE008</td><td>Modifier</td></tr>
      <tr><td>LEFT_SHIFT</td><td>\uE008</td><td>Modifier</td></tr>
      <tr><td>CONTROL</td><td>\uE009</td><td>Modifier</td></tr>
      <tr><td>LEFT_CONTROL</td><td>\uE009</td><td>Modifier</td></tr>
      <tr><td>ALT</td><td>\uE00A</td><td>Modifier</td></tr>
      <tr><td>LEFT_ALT</td><td>\uE00A</td><td>Modifier</td></tr>
      <tr><td>PAUSE</td><td>\uE00B</td><td>Special key</td></tr>
      <tr><td>ESCAPE</td><td>\uE00C</td><td>Special key</td></tr>
      <tr><td>SPACE</td><td>\uE00D</td><td>Special key</td></tr>
      <tr><td>PAGE_UP</td><td>\uE00E</td><td>Special key</td></tr>
      <tr><td>PAGE_DOWN</td><td>\uE00F</td><td>Special key</td></tr>
      <tr><td>END</td><td>\uE010</td><td>Special key</td></tr>
      <tr><td>HOME</td><td>\uE011</td><td>Special key</td></tr>
      <tr><td>LEFT</td><td>\uE012</td><td>Special key</td></tr>
      <tr><td>ARROW_LEFT</td><td>\uE012</td><td>Special key</td></tr>
      <tr><td>UP</td><td>\uE013</td><td>Special key</td></tr>
      <tr><td>ARROW_UP</td><td>\uE013</td><td>Special key</td></tr>
      <tr><td>RIGHT</td><td>\uE014</td><td>Special key</td></tr>
      <tr><td>ARROW_RIGHT</td><td>\uE014</td><td>Special key</td></tr>
      <tr><td>DOWN</td><td>\uE015</td><td>Special key</td></tr>
      <tr><td>ARROW_DOWN</td><td>\uE015</td><td>Special key</td></tr>
      <tr><td>INSERT</td><td>\uE016</td><td>Special key</td></tr>
      <tr><td>DELETE</td><td>\uE017</td><td>Special key</td></tr>
      <tr><td>SEMICOLON</td><td>\uE018</td><td>Special key</td></tr>
      <tr><td>EQUALS</td><td>\uE019</td><td>Special key</td></tr>
      <tr><td>NUMPAD0</td><td>\uE01A</td><td>Special key</td></tr>
      <tr><td>NUMPAD1</td><td>\uE01B</td><td>Special key</td></tr>
      <tr><td>NUMPAD2</td><td>\uE01C</td><td>Special key</td></tr>
      <tr><td>NUMPAD3</td><td>\uE01D</td><td>Special key</td></tr>
      <tr><td>NUMPAD4</td><td>\uE01E</td><td>Special key</td></tr>
      <tr><td>NUMPAD5</td><td>\uE01F</td><td>Special key</td></tr>
      <tr><td>NUMPAD6</td><td>\uE020</td><td>Special key</td></tr>
      <tr><td>NUMPAD7</td><td>\uE021</td><td>Special key</td></tr>
      <tr><td>NUMPAD8</td><td>\uE022</td><td>Special key</td></tr>
      <tr><td>NUMPAD9</td><td>\uE023</td><td>Special key</td></tr>
      <tr><td>MULTIPLY</td><td>\uE024</td><td>Special key</td></tr>
      <tr><td>ADD</td><td>\uE025</td><td>Special key</td></tr>
      <tr><td>SEPARATOR</td><td>\uE026</td><td>Special key</td></tr>
      <tr><td>SUBTRACT</td><td>\uE027</td><td>Special key</td></tr>
      <tr><td>DECIMAL</td><td>\uE028</td><td>Special key</td></tr>
      <tr><td>DIVIDE</td><td>\uE029</td><td>Special key</td></tr>
      <tr><td>F1</td><td>\uE031</td><td>Special key</td></tr>
      <tr><td>F2</td><td>\uE032</td><td>Special key</td></tr>
      <tr><td>F3</td><td>\uE033</td><td>Special key</td></tr>
      <tr><td>F4</td><td>\uE034</td><td>Special key</td></tr>
      <tr><td>F5</td><td>\uE035</td><td>Special key</td></tr>
      <tr><td>F6</td><td>\uE036</td><td>Special key</td></tr>
      <tr><td>F7</td><td>\uE037</td><td>Special key</td></tr>
      <tr><td>F8</td><td>\uE038</td><td>Special key</td></tr>
      <tr><td>F9</td><td>\uE039</td><td>Special key</td></tr>
      <tr><td>F10</td><td>\uE03A</td><td>Special key</td></tr>
      <tr><td>F11</td><td>\uE03B</td><td>Special key</td></tr>
      <tr><td>F12</td><td>\uE03C</td><td>Special key</td></tr>
      <tr><td>META</td><td>\uE03D</td><td>Special key</td></tr>
      <tr><td>COMMAND</td><td>\uE03D</td><td>Special key</td></tr>
      <tr><td>ZENKAKU_HANKAKU</td><td>\uE040</td><td>Special key</td></tr>
    </table>
    <p>The keys considered upper-case symbols are either defined by the current keyboard locale or are derived from the US 104 keys Windows keyboard layout, which are:
    <ul>
      <li>A - Z</li>
      <li>!$^*()+{}:?|~@#%_\" &amp; &lt; &gt;</li>
    </ul>
    <p>When the user input is emulated natively (see note below), the implementation SHOULD use the current keyboard locale to determine which symbols are upper case. In all other cases, the implementation MUST use the US 104 key Windows keyboard layout to determine those symbols.</p>
    <p>The state of the physical keyboard MUST NOT affect emulated user input.</p>
    <h3>Internationalized input</h3>
    <p>Non-latin symbols: TBD</p>
    <p>Complex scripts using Input Method Editor (IME): TBD</p>
    </section> <!-- typing -->
    </section> <!-- high-level APIs -->
</section>
