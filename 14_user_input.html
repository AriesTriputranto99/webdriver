<section>
  <h2>User Input</h2>
  <p>The WebDriver API offers two ways of interacting with elements,
    either with a set of low-level "do as I say" commands, or a
    high-level "do as I mean" set of commands. The former are offered to
    allow precise emulation of user input. The latter are offered as a
    convenience to cover the common case, and can conceivably be
    implemented on top of the lower level primitive operations.</p>

  <section>
    <h2 id="interactable">Interactable elements</h2>
    <p>Some user actions require the element to be interactable. The following conditions must be met for the element to be considered interactable:
    <ul>
      <li>The element MUST be displayed, as defined in <a href="#determining-if-displayed">section 10.1</a>.</li>
      <li>The element MUST NOT be disabled. "Disabled" is defined as:
      <ul>
        <li>If the current document is being processed as an HTML document, the element MUST be considered disabled if it does not support
        the <a href="http://www.w3.org/TR/html401/interact/forms.html#adef-disabled">disabled</a>
        attribute (according to the [[!html51]] spec), or if the
        disabled attribute is set in the case where that attribute is present.</li>
      </ul>
      </li>
    </ul>
    </section>

    <section>
      <h2>Low Level Commands</h2>
      <p>The low level commands provide a mechanism for precisely stating how a user can interact with the browser.

      <p><a href='http://www.w3.org/TR/DOM-Level-3-Events/#glossary-activation-trigger'>Activation triggers</a> generated by the WebDriver API User SHOULD be indistinguishable from those generated by a real user
        interacting with the browser.</p>
      <p class='note'>
        In particular, the dispatched events will have the <a href='http://dom.spec.whatwg.org/#dom-event-istrusted'>isTrusted</a> attribute set to true. The most robust way to dispatch these events is by creating them in the browser implementation itself. Sending OS-specific input messages to the browser's window has the disadvantage that the browser being automated may not be properly isolated from a user accidentally modifying input device state; use of an OS-level accessibility API has the disadvantage that the browser's window must be focused, and as a result, multiple tests cannot run in parallel.
      </p>

      <section>
        <h2>Actions</h2>
        <p>Actions are a way of executing a chain of low-level commands to emulate a user action.
          For example, if you wish to automate a drag and drop action in a browser, you would chain
          the clickAndHoldAction, moveMouseAction and buttonReleaseAction commands together. This
          implies chaining actions together to form a user action.
        <p>The remote side will receive the actions, and execute them, returning a response to the local end once the entire
          action sequence has been performed.  Actions will be
          created by chaining the low-level commands together on either a MouseAction or TouchAction
          object. Each action's sequence MUST be sent over to the remote end
          with one call with the entire sequence in the <a href="#command-1">Command</a> when the perform()
          method is called.
        <section>
          <h2>Mouse Interactions</h2>
          <p>
            <dl title="enum Button" class='idl'>
              <dt>LEFT</dt>
              <dd>The left button on a mouse</dd>
              <dt>MIDDLE</dt>
              <dd>The middle button on a mouse</dd>
              <dt>RIGHT</dt>
              <dd>The right button on a mouse</dd>
            </dl>
            <dl class="idl" title="interface MouseAction">
                <dt>void buttonDown()</dt>
                <dd>Click any mouse button (at the coordinates set by the last moveto command). Note that calling this command after calling buttondown and before calling button up (or any out-of-order interactions sequence) will yield undefined behaviour).
                  <p>
                  <p>The possible errors for this command:
                  <dl class='parameters'>
                    <dt>optional Button button</dt>
                    <dd>The button that will start the chain of events being fired. If no argument is passed in then the User Agent should default to <code>LEFT</code></dd>
                  </dl>
                </dd>
                <dt>void buttonUp()</dt>
                <dd>Releases the mouse button previously held (where the mouse is currently at). Must be called once for every buttondown command issued. See the note in click and buttondown about implications of out-of-order commands.
                  <dl class='parameters'>
                    <dt>optional Button button</dt>
                    <dd>The button that will start the chain of events being fired. If no argument is passed in then the User Agent should default to <code>LEFT</code></dd>
                  </dl>
                </dd>
                <dt>void click ()</dt>
                <dd>
                  Click any mouse button (at the coordinates set by the last moveto command). Note that calling this command after calling buttondown and before calling button up (or any out-of-order interactions sequence) will yield undefined behaviour).
                  <dl class='parameters'>
                    <dt>optional Button button</dt>
                    <dd>The button that will start the chain of events being fired. If no argument is passed in then the User Agent should default to <code>LEFT</code></dd>
                  </dl>
                </dd>
                <dt>void doubleClick ()</dt>
                <dd>Double-clicks at the current mouse coordinates (set by moveTo)</dd>
                <dt>void moveTo ()</dt>
                <dd>
                  Move the mouse by an offset of the specificed element. If no element is specified, the move is relative to the current mouse cursor. If an element is provided but no offset, the mouse will be moved to the center of the element. If the element is not visible, it will be scrolled into view.
                  <dl class='parameters'>
                    <dt>optional WebElement? id</dt>
                    <dd>The ID of the <a>WebElement</a> on which to operate.</dd>
                    <dt>optional long x</dt>
                    <dd>The x-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a>.</dd>
                    <dt>optional long y</dt>
                    <dd>The y-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a>.</dd>
                  </dl>
                </dd>
                <dt>void perform ()</dt>
                <dd>Perform should be implemented to allow for the execution of segmented Interactions, so one call to perform() will execute everything in the actions object, and provided that either <code>release()</code> or <code>mouseup()</code> have not been called, then the MouseAction or TouchAction object can still be used, so more actions can be added, and <code>perform()</code> can be called as many times as necessary. This enables you to use webdriver for other tasks during a gesture. For example, if you want to hold down an element, then wait for an element to appear, then mouse over onto the new element, you can use one MouseAction chain to start the mousedown event, call perform, then call findElement, then use the same MouseAction chain to add a mousemove event to the newly found element and another event to release the button, and then call perform.
                  <p class="note">
                    action_chain = MouseAction()<br>
                    action_chain.mouseDown(element1).perform()<br>
                    element2 = webdriver.findElement(some_locator)<br>
                    action_chain.mouseMove(element2).buttonRelease().perform()<br>
                  </p>
                </dd>
            </dl>
        </section>

        <section>
          <h2>Touch Gestures</h2>
          <p>By the nature of touch events, all touch events are dispatched using the target of the initial <a>WebElement</a> that receives the events. You cannot have more than one touch action active at one time with single Action chains. If multi-finger gestures are needed, use <a href='#multiactions'>MultiAction chains</a>.</p>
            <dl class="idl" title='interface TouchAction'>
                <!-- Press -->
                <dt>void press()</dt>
                <dd>Tap and hold in the middle of the <a>WebElement</a> or at coordinates (x, y) relative to the top-left corner of the target <a>WebElement</a>. The middle of the element is defined as the middle of the box returned by
                  calling <code><a
                    href="http://www.w3.org/TR/cssom-view/#the-getclientrects()-and-getboundingclientrect()-methods">getBoundingClientRect</a></code>
                  on the underlying document Element, according to the [[!CSSOM-VIEW]] spec. If
                  the element is outside the <a
                    href="http://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
                  (according to the [[!CSS21]] spec), the implementation SHOULD bring the
                  element into view first. The implementation MAY invoke <code>scrollIntoView</code> on
                  the underlying document Element.
                <br>
                <br>
                  The possible errors for this command:
                  <ul>
                    <li><code><a href="#status-stale-element-reference">stale element reference</a></code> if the given element is no longer in the <a href="http://dom.spec.whatwg.org/#in-a-document">document</a>.
                    <li><code><a href="#status-move-target-out-of-bounds">move target out of bounds</a></code> if the element cannot be scrolled into view.
                    <li><code><a href="#status-unsupported-operation">unsupported_operation</a></code> if press has already been called without a subsequent release call.
                  </ul>
                  <br>
                  <dl class='parameters'>
                    <dt>WebElement id</dt>
                    <dd>The ID of the <a>WebElement</a> on which to operate.</dd>
                    <dt>optional Long x</dt>
                    <dd>The x-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a>.</dd>
                    <dt>optional Long y</dt>
                    <dd>The y-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a>.</dd>
                  </dl>
                </dd>
                <!-- Release -->
                <dt>void release ()</dt>
                <dd>This is the equivalent of the user removing their finger from the touch screen. All the relevant events MUST fire when this happens. If there is another release() call then this should be ignored until either longPress() or press() is called again.
                </dd>
                <!-- Move -->
                <dt>void moveTo ()</dt>
                <dd>Drag the <a>WebElement</a> to another <a>WebElement</a> that has the id equal to what is passed in as an argument. The drag starts from the centre of the <a>WebElement</a>
                  <p class='note'>
                    In a chain where element1 is pressed, resulting in a <code>touchstart</code> event on coordinates (x1,y1), and is followed by MoveByOffset with coordinates (x2, y2), then the <code>touchmove</code> event will be dispatched at (x1+x2, y1+y2).
                  </p>
                  <br>
                  <br>
                    The possible errors for this command:
                    <ul>
                      <li><code><a href="#status-stale-element-reference">stale element reference</a></code> if the given element is no longer in the <a href="http://dom.spec.whatwg.org/#in-a-document">document</a>.
                      <li><code><a href="#status-move-target-out-of-bounds">move target out of bounds</a></code> if the element cannot be scrolled into view.
                    </ul>
                    <br>
                  <dl class="parameters">
                    <dt>WebElement id</dt>
                    <dd>The ID of the <a>WebElement</a> on which to operate.</dd>
                    <dt>optional Long x</dt>
                    <dd>The x-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a></dd>
                    <dt>optional Long y</dt>
                    <dd>The y-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a></dd>
                  </dl>
                </dd>
                <!-- Tap -->
                <dt>void tap ()</dt>
                <dd>Tap in the middle of the <a>WebElement</a> or at coordinates (x, y) relative to the top-left corner of the target <a>WebElement</a>. The middle of the element is defined as the middle of the box returned by
                  calling <code><a
                    href="http://www.w3.org/TR/cssom-view/#the-getclientrects()-and-getboundingclientrect()-methods">getBoundingClientRect</a></code>
                  on the underlying document Element, according to the [[!CSSOM-VIEW]] spec. If
                  the element is outside the <a
                    href="http://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
                  (according to the [[!CSS21]] spec), the implementation SHOULD bring the
                  element into view first. The implementation MAY invoke <code>scrollIntoView</code> on
                  the underlying document Element.
                  <p> If count is greater than one then the necessary events should be fired at the <a>WebElement</a>.
                  <p>The possible errors for this command:
                  <ul>
                    <li><code><a href="#status-stale-element-reference">stale element reference</a></code> if the given element is no longer in the <a href="http://dom.spec.whatwg.org/#in-a-document">document</a>.</li>
                    <li><code><a href="#status-move-target-out-of-bounds">move target out of bounds</a></code> if the element cannot be scrolled into view.</li>
                  </ul>
                  <p>
                  <dl class='parameters'>
                    <dt>WebElement id</dt>
                    <dd>The ID of the <a>WebElement</a> on which to operate.</dd>
                    <dt>optional Long x</dt>
                    <dd>The x-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a>.</dd>
                    <dt>optional Long y</dt>
                    <dd>The y-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a>.</dd>
                    <dt>UnsignedShort? count</dt>
                    <dd>The number of taps that will be performed before returning to the local end. If <code>count</code> is null or no argument is passed in then 1 tap MUST be executed.</dd>
                  </dl>
                </dd>
                <!-- Wait -->
                <dt>void wait ()</dt>
                <dd>Pause execution of action chain for the given number of milliseconds. Defaults to zero so that it can be used for synchronising actions. If <code>null</code> is passed into the method the User Agent MUST treat it as though it was zero.
                  <dl class="parameters">
                    <dt>optional long? ms</dt>
                    <dd>The time in milliseconds to wait before performing next action</dd>
                  </dl>
                </dd>
                <!-- Long Press -->
                <dt>void longPress ()</dt>
                <dd>Tap in the middle of the <a>WebElement</a> or at coordinates (x, y) relative to the top-left corner of the target <a>WebElement</a> and hold until the <code>contextmenu</code> event has fired. The middle of the element is defined as the middle of the box returned by
                  calling <code><a
                    href="http://www.w3.org/TR/cssom-view/#the-getclientrects()-and-getboundingclientrect()-methods">getBoundingClientRect</a></code>
                  on the underlying document Element, according to the [[!CSSOM-VIEW]] spec. If
                  the element is outside the <a
                    href="http://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
                  (according to the [[!CSS21]] spec), the implementation SHOULD bring the
                  element into view first. The implementation MAY invoke <code>scrollIntoView</code> on
                  the underlying document Element.
                  <br>
                  <br>
                    The possible errors for this command:
                    <ul>
                      <li><code><a href="#status-stale-element-reference">stale element reference</a></code> if the given element is no longer in the <a href="http://dom.spec.whatwg.org/#in-a-document">document</a>.
                      <li><code><a href="#status-move-target-out-of-bounds">move target out of bounds</a></code> if the element cannot be scrolled into view.
                      </ul>
                    <br>
                  <dl class='parameters'>
                    <dt>WebElement id</dt>
                    <dd>The ID of the <a>WebElement</a> on which to operate.</dd>
                    <dt>optional long x</dt>
                    <dd>The x-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a>.</dd>
                    <dt>optional long y</dt>
                    <dd>The y-coordinate offset to send the touch event, from the top-left coordinate of the given <a>WebElement</a>.</dd>
                  </dl>
                </dd>
                <!-- Cancel -->
                <dt>void cancel ()</dt>
                <dd>The User Agent MUST cancel the current touch action being executed.
                </dd>
                <!-- Perform -->
                <dt>void perform ()</dt>
                <dd>Perform should be implemented to allow for the execution of segmented Interactions, so one call to perform() will execute everything in the actions object, and provided that either <code>release()</code> or <code>mouseup()</code> have not been called, then the TouchAction object can still be used, so more actions can be added, and <code>perform()</code> can be called as many times as necessary. This enables you to use webdriver for other tasks during a gesture. For example, if you want to hold down an element, then wait for an element to appear, then mouse over onto the new element, you can use one TouchAction chain to start the mousedown event, call perform, then call findElement, then use the same TouchAction chain to add a mousemove event to the newly found element and another event to release the button, and then call perform.
                  <p class="note">
                    action_chain = TouchAction()<br>
                    action_chain.press().perform()<br>
                    element2 = webdriver.findElement(some_locator)<br>
                    action_chain.move_to(element2).release().perform()<br>
                  </p>
                </dd>
            </dl>
      </section>

       </section>
       <section>
         <h2 id='multiactions'>MultiActions</h2>
         <p>Automating gestures is different from automating mouse interactions since we can have any number of fingers simultaneously acting on the touch surface. A typical 'scroll' action requires two fingers, but it is possible that we may have multi-finger gestures, or in an extrapolated case, that more than one person will operate the same touch surface, say in the case of a competitive multiplayer game. These cases mean we must allow for any number of actions occuring simulateously. This demands a MultiAction. By having a TouchAction represent the gestures of one finger, we can perform multi-finger gestures by adding these single finger gestures together, using MultiAction:
         <dl class="idl" title="interface MultiAction">
             <dt>void add (TouchAction touchAction)</dt>
             <dd>The local end must add the <code>TouchAction</code> sequence to an array which can then be serialised when <code>perform()</code>
               is called.
               <br>
               <br>
               <dl class='parameters'>
                 <dt>TouchAction touchAction</dt>
                 <dd>A touchAction object that has been populated with the action sequence that the user would like to execute on the remote end</dd>
               </dl>
             </dd>
             <dt>void perform ()</dt>
             <dd> <p>MultiAction can take in as many TouchAction objects as needed, by using the add command. When perform is called, the remote end is responsible for executing the individual actions from each TouchAction in the right group, and in the correct order. Note, the "right group" is used to denote "in the same execution group", and is not meant to denote dispatching the events at exactly the same time. For example, to automate a gesture where one finger presses, holds and releases an element while another finger moves from one element to another:
             <p class="note">
               action1 = TouchAction()<br>
               action2 = TouchAction()<br>
               action1.press(element1).wait(5).release(element1)<br>
               action2.press(element2).move(element3).release(element3)<br>
               multi = MultiAction()<br>
               multi.add(action1).add(action2)<br>
               multi.perform()
             </p>
             In this example, the remote end will find the first actions in each action object, and will perform them as part of the same execution group. This means the first execution group will be <code>press(element1)</code> and <code>press(element2)</code>. After these events are dispatched, the remote end will will find the next execution group to perform. It will execute <code>wait(5)</code> and <code>move(element3)</code>. Then it will find the next execution group, in this case, it is just <code>release(element1)</code> and <code>release(element3)</code>. When there are no more actions to perform on any of the TouchAction objects, then perform() will return.
             <br>
             <br>
             MultiAction objects do not demand that all of its member TouchActions have the same number of actions. It is possible for one TouchAction object to have more actions than another. The perform function iterates over the actions in order, and it is possible to have only one action in an execution group like so:
             <p class="note">
               action = TouchAction()<br>
               action = TouchAction()<br>
               action.press(element1).wait(5).release(element1)<br>
               action.press(element2).release(element3)<br>
               multi = MultiAction()<br>
               multi.add(action1).add(action2)<br>
               multi.perform()
             </p>
             In this case, there will be three execution groups, the last one having only <code>release(element1)</code> in it.
             <br>
             <br>
             Note: In addition to the wait command being used to indicate how long to wait, if used without arguments, it is used to indicate that nothing should be done for one TouchAction during an execution group. For example:
             <p class="note">
               action1 = TouchAction()<br>
               action2 = TouchAction()<br>
               action1.press(element1).move(element2).release(element2)<br>
               action2.press(element3).wait().release(element3)<br>
               multi = MultiAction()<br>
               multi.add(action1).add(action2)<br>
               multi.perform()
             </p>
             Here <code>wait()</code> is used to indicate to the remote end that nothing should be done for action2 in the second execution group. So the second execution group will just be <code>move(element2)</code>, but the third group will be <code>release(element2)</code> and <code>release(element3)</code>
           </dd>
         </dl>
         </section>
      </section> <!-- low-level wire protocol commands -->

    <section>
      <h2>High Level Commands</h2>
        <p>These higher level commands SHOULD be built on top of the low level commands, and implement a user friendly way of interacting with a page in a way that models common user expectations.

        <section>
          <h2 id='high-level-click'>Clicking</a></h2>
          <dl class="idl" title="partial interface WebElement">
            <dt>void click()</dt>
            <dd>Click in the middle of the <a>WebElement</a> instance. The middle of the element is defined as the middle of the box returned by
            calling <code><a
              href="http://www.w3.org/TR/cssom-view/#the-getclientrects()-and-getboundingclientrect()-methods">getBoundingClientRect</a></code>
            on the underlying document Element, according to the [[!CSSOM-VIEW]] spec. If
            the element is outside the <a
              href="http://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
            (according to the [[!CSS21]] spec), the implementation SHOULD bring the
            element into view first. The implementation MAY invoke <code>scrollIntoView</code> on
            the underlying document Element. The element MUST be <a
              href="#determining-if-displayed">displayed</a>. See the note below for when the element is obscured by another element.
            Exceptions:
            <ul>
              <li>Links (A elements): Clicking happens in the middle of the first
                <a href="#determining-if-displayed">displayed</a> bounding client rectangle. This is to overcome overflowing links where the middle of the bounding client rectangle does not actually fall on a clickable part of the link.</li>
              <li>SELECT elements without the &quot;multiple&quot; attribute set.
                Clicking on the select element SHOULD open the drop down menu. The next
                click, on any element, MUST close this menu.</li>
              <li>Clicking directly on an OPTION element (without clicking on the
                parent SELECT element previously) MUST open a selection menu, as if the
                SELECT option was clicked first, then click on the OPTION before finally
                closing the SELECT element's menu. The SELECT menu MUST be closed
                once the action is complete.</li>
            </ul>
            <p>The possible errors for this command:
            <ul>
              <li><code><a href="#status-stale-element-reference">stale element reference</a></code> if the given element is no longer in the <a href="http://dom.spec.whatwg.org/#in-a-document">document</a>.</li>
              <li><code><a href="#status-element-not-visible">element not visible</a></code> if the element is hidden and thus cannot be interacted with.</li>
              <li><code><a href="#status-move-target-out-of-bounds">move target out of bounds</a></code> if the element cannot be scrolled into view.</li>
            </ul>
            <p>This command MUST use either the mouse or touch mechanisms for
              emulating the user input. In the case where the browser being automated
              supports only mouse input or both mouse and touch input, the low-level
              mouse mechanisms MUST be used. If the browser only supports touch input,
              the low level touch inputs MUST be used.</p>
            </dd>
          </dl>
          <p class="note">As the goal is to emulate users as closely as possible, the
            implementation SHOULD NOT allow clicking on elements that are obscured by
            other elements. If the implementation forbids clicking on obscured elements,
            an <code><a href="#status-element-not-visible">element not visible</a></code> response MUST be returned and this SHOULD have an
            explantory message explaining the reason. The implementation SHOULD try to
            scroll the element into view, but in case it is fully obscured, it SHOULD
            NOT be clickable.<!--TODO: add details of interactable'--></p>
        </section>
        <section>
          <h2>Touch</h2>
          <p>This section defines the low level commands used when manipulating touch-enabled devices. These are the building blocks of touch interaction chains.</p>
          <!--<p>NOTE: would like to add pressure/tilt, but that isn't in Touch Events (http://www.w3.org/TR/touch-events/), will have to wait for Pointer Event adoption</p>-->
          <table class="simple">
            <tr><td>Capability Name</td><td>Type</td></tr>
            <tr><td><span id="capability-touchEnabled">touchEnabled</span></td><td>boolean</td></tr>
          </table>
          <br>
          <br>
          <dl class='idl' title='partial interface WebElement'>
            <!-- Tap -->
            <dt>void tap ()</dt>
            <dd>Tap in the middle of the <a>WebElement</a>. The middle of the element is defined as the middle of the box returned by
              calling <code><a
                href="http://www.w3.org/TR/cssom-view/#the-getclientrects()-and-getboundingclientrect()-methods">getBoundingClientRect</a></code>
              on the underlying document Element, according to the [[!CSSOM-VIEW]] spec. If
              the element is outside the <a
                href="http://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
              (according to the [[!CSS21]] spec), the implementation SHOULD bring the
              element into view first. The implementation MAY invoke <code>scrollIntoView</code> on
              the underlying document Element.
              Exceptions:
              <ul>
                <li>Links (A elements): Clicking happens in the middle of the first
                  <a href="#determining-if-displayed">displayed</a> bounding client rectangle. This is to overcome overflowing links where the middle of the bounding client rectangle does not actually fall on a clickable part of the link.</li>
                <li>SELECT elements without the &quot;multiple&quot; attribute set.
                  Clicking on the select element SHOULD open the drop down menu. The next
                  click, on any element, MUST close this menu.</li>
                <li>Clicking directly on an OPTION element (without clicking on the
                  parent SELECT element previously) MUST open a selection menu, as if the
                  SELECT option was clicked first, then click on the OPTION before finally
                  closing the SELECT element's menu. The SELECT menu MUST be closed
                  once the action is complete.</li>
              </ul>
              <p>The possible errors for this command:
              <ul>
                <li><code><a href="#status-stale-element-reference">stale element reference</a></code> if the given element is no longer in the <a href="http://dom.spec.whatwg.org/#in-a-document">document</a>.</li>
                <li><code><a href="#status-move-target-out-of-bounds">move target out of bounds</a></code> if the element cannot be scrolled into view.</li>
              </ul>
            </dd>
          </dl>
        </section>
      <section>
        <h2 id='typing_keys'>Typing keys</h2>
        <p>A requirement for key-based interaction with an element is that it is
          <a href="#interactable">interactable</a>. Typing into an element is permitted if one of the following conditions is met:
            <ul>
              <li>The element is <a href="http://dev.w3.org/html5/spec/editing.html#focus">focusable</a> as defined in the editing section of the [[!html51]] spec.</li>
              <li>The element is allowed to be the <code><a href='http://www.w3.org/html/wg/drafts/html/master/editing.html#dom-document-activeelement'>activeElement</a></code>. In
              addition to focusable elements, this allows typing to the <code>BODY</code> element.</li>
              <li>In an HTML document, the element is <a href="http://dev.w3.org/html5/spec/editing.html#attr-contenteditable">editable</a> as a result of having its <code>contentEditable</code> attribute set or the containing document is in <code>designMode</code>.</li>
              <li>The underlying browser implementation would allow keyboard input to
              directed to the element (eg. an HTML document with a DIV marked as being
              contentEditable)</li>
            </ul>
        <p>Prior to any keyboard interaction, an attempt to shift focus to the
        element MUST be attempted if the element does not currently have the focus. This is the case if one of the following
        holds:
        <ul>
          <li>The element is not already the document's <code><a href='http://www.w3.org/html/wg/drafts/html/master/editing.html#dom-document-activeelement'>activeElement</a></code>.</li>
          <li>The owner document of the element to be interacted with is not the focused document.</li>
        </ul>
        <p>In case focusing is needed, the implementation MUST follow the <a href="http://dev.w3.org/html5/spec/editing.html#focus-management"><b>focusing steps</b></a> as described in the focus management section of the [[!html51]] spec. The focus MUST NOT leave the element at the end of the interaction, other than as a result of the interaction itself (i.e. when the tab key is sent).
        </p>
        <dl class="idl" title="partial interface WebElement">
          <dt>void clear()</dt>
          <dd>Clears the value of the element.</dd>
          <dt>void sendKeys(string keysToSend)</dt>
          <dd>Sends a sequence of keyboard events representing the keys in the keysToSend parameter.
            <p>Caret positioning: If focusing was needed, after following the focusing steps, the caret MUST be positioned at the end of the text currently in the element. At the end of the interaction, the caret MUST be positioned at the end of the typed text sequence, unless the keys sent position it otherwise (e.g. using the LEFT key).</p>
            <p>There are four different types of keys that are emulated:
            <ul>
              <li>Character literals - lower-case symbols.</li>
              <li>Uppercase letters and symbols requiring the SHIFT key for typing.</li>
              <li>Modifier keys</li>
              <li>Special keys</li>
            </ul>The rest of this section details the values used to represent the different keys, as well as the expected behaviour for each key type.</dd>
        </dl>
        <p>When emulating user input, the implementation MUST generate
        the same sequence of events that would have been produced if a real user was
        sitting in front of the keyboard and typing the sequence of characters. In
        cases where there is more than one way to type this sequence, the
        implementation MUST choose one of the valid ways. For example, typing <code>AB</code> may be achieved by:
        <ul>
          <li>Holding down the Shift key</li>
          <li>Pressing the letter 'a'</li>
          <li>Pressing the letter 'b'</li>
          <li>Releasing the Shift key</li>
        </ul>
        Alternatively, it can be achieved by:
        <ul>
          <li>Holding down the Shift key</li>
          <li>Pressing the letter 'a'</li>
          <li>Releasing the Shift key</li>
          <li>Holding down the Shift key</li>
          <li>Pressing the letter 'b'</li>
          <li>Releasing the Shift key</li>
        </ul>
        <p>Or by simply turning on the CAPS LOCK first.</p>
        <p>
        The implementation MAY use the following algorithm to generate the events.
        If the implementation is using a different algorithm, it MUST adhere to the
        requirements listed below.
        <p>For each key, <var>key</var> in <var>keysToSend</var>, do
        <ol>
          <li>If <var>key</var> is a lower-case symbol:
          <ol>
            <li>If the Shift key is not pressed:
              <ol>
                <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events with
                <var>key</var> as
                the character to emulate</li>
              </ol>
            </li>
            <li>else (The Shift key is pressed)
              <ol>
                <li>let <var>uppercaseKey</var> be the upper-case character matching
                <var>key</var></li>
                <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events with
                <var>uppercaseKey</var> as the character to emulate</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Else if <var>key</var> is an upper-case symbol:
          <ol>
            <li>If the Shift key is not pressed:
            <ol>
              <li>Generate a <code>keydown</code> event of the Shift key.
              <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events with
              <var>key</var> as
              the character to emulate</li>
              <li>Generate a <code>keyup</code> event of the Shift key.
            </ol>
          </li>
          <li>else (The Shift key is pressed)
            <ol>
              <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events with
              <var>key</var> as the character to emulate</li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Else if <var>key</var> represents a modifier key:
        <ol>
          <li>let <var>modifier</var> be the modifier key represented by
          <var>key</var></li>
          <li>If <var>modifier</var> is currently held down:
        <ol>
      <li>Generate a <code>keyup</code> event of <var>modifier</var></li>
    </ol>
  </li>
  <li>Else:
    <ol>
      <li>Generate a <code>keydown</code> event of <var>modifier</var></li>
    </ol>
  </li>
  <li>Maintain this key state and use it to modify the input until it is pressed again.</li>
</ol>
      </li>
      <li>Else if <var>key</var> represents the NULL key:
      <ol>
        <li>Generate <code>keyup</code> events of all modifier keys currently held
        down.</li>
        <li>All modifier keys are now assumed to be released.</li>
      </ol>
      </li>
      <li>Else if <var>key</var> represents a special key:
      <ol>
        <li>Translate <var>key</var> to the special key it represents</li>
        <li>Generate a sequence of <code>keydown</code>, <code>keypress</code> and <code>keyup</code> events for the special key.</li>
      </ol>
      </li>
    </ol>
    <p>Once keyboard input is complete, an implicit <var>NULL</var> key is sent unless the
    final character is the <var>NULL</var> key.</p>
    <p> <!-- Pseudo-code --></p>
    <p>Any implementation MUST comply with these requirements:
    <ul>
      <li>For uppercase letters and symbols that require the Shift key to be
      pressed, there are two options:
      <ul>
        <li>A single Shift <code>keydown</code> event is generated before the entire
        sequence of uppercase letters.</li>
        <li>Before each such letter or symbol, a Shift <code>keydown</code> event is
        generated. After each letter or symbol, a Shift <code>keyup</code> event is
        generated.</li>
      </ul></li>
      <li>A user-specified Shift press implies capitalization of all following
      characters.</li>
      <li>If a user-specified Shift press precedes uppercase letters and
      symbols, a second Shift <code>keydown</code> event MUST NOT be generated. In that
      case, a Shift <code>keyup</code> event MUST NOT be generated implicitly by the
      implementation.</li>
      <li>The <var>NULL</var> key releases all currently held down modifier keys.</li>
      <li>The state of all modifier keys must be reset at the end of each
      <code>sendKeys</code> call and the appropriate <code>keyup</code> events
      generated</li>
    </ul>
    <p> <!-- Algorithm paragraph --></p>
    <h3>Character types</h3>
    <p>The <var>keysToSend</var> parameter contains a mix of printable
    characters and pressable keys that aren't text. Pressable keys that aren't
    text are stored in the Unicode PUA (Private Use Area) code points,
    0xE000-0xF8FF. The following table describes the mapping between PUA and
    key:
    <table class="simple">
      <tr>
        <th>Key</th>
        <th>Code</th>
        <th>Type</th>
      </tr>
      <tr><td>NULL</td><td>\uE000</td><td>NULL</td></tr>
      <tr><td>CANCEL</td><td>\uE001</td><td>Special key</td></tr>
      <tr><td>HELP</td><td>\uE002</td><td>Special key</td></tr>
      <tr><td>BACK_SPACE</td><td>\uE003</td><td>Special key</td></tr>
      <tr><td>TAB</td><td>\uE004</td><td>Special key</td></tr>
      <tr><td>CLEAR</td><td>\uE005</td><td>Special key</td></tr>
      <tr><td>RETURN</td><td>\uE006</td><td>Special key</td></tr>
      <tr><td>ENTER</td><td>\uE007</td><td>Special key</td></tr>
      <tr><td>SHIFT</td><td>\uE008</td><td>Modifier</td></tr>
      <tr><td>CONTROL</td><td>\uE009</td><td>Modifier</td></tr>
      <tr><td>ALT</td><td>\uE00A</td><td>Modifier</td></tr>
      <tr><td>PAUSE</td><td>\uE00B</td><td>Special key</td></tr>
      <tr><td>ESCAPE</td><td>\uE00C</td><td>Special key</td></tr>
      <tr><td>SPACE</td><td>\uE00D</td><td>Special key</td></tr>
      <tr><td>PAGE_UP</td><td>\uE00E</td><td>Special key</td></tr>
      <tr><td>PAGE_DOWN</td><td>\uE00F</td><td>Special key</td></tr>
      <tr><td>END</td><td>\uE010</td><td>Special key</td></tr>
      <tr><td>HOME</td><td>\uE011</td><td>Special key</td></tr>
      <tr><td>ARROW_LEFT</td><td>\uE012</td><td>Special key</td></tr>
      <tr><td>ARROW_UP</td><td>\uE013</td><td>Special key</td></tr>
      <tr><td>ARROW_RIGHT</td><td>\uE014</td><td>Special key</td></tr>
      <tr><td>ARROW_DOWN</td><td>\uE015</td><td>Special key</td></tr>
      <tr><td>INSERT</td><td>\uE016</td><td>Special key</td></tr>
      <tr><td>DELETE</td><td>\uE017</td><td>Special key</td></tr>
      <tr><td>SEMICOLON</td><td>\uE018</td><td>Special key</td></tr>
      <tr><td>EQUALS</td><td>\uE019</td><td>Special key</td></tr>
      <tr><td>NUMPAD0</td><td>\uE01A</td><td>Special key</td></tr>
      <tr><td>NUMPAD1</td><td>\uE01B</td><td>Special key</td></tr>
      <tr><td>NUMPAD2</td><td>\uE01C</td><td>Special key</td></tr>
      <tr><td>NUMPAD3</td><td>\uE01D</td><td>Special key</td></tr>
      <tr><td>NUMPAD4</td><td>\uE01E</td><td>Special key</td></tr>
      <tr><td>NUMPAD5</td><td>\uE01F</td><td>Special key</td></tr>
      <tr><td>NUMPAD6</td><td>\uE020</td><td>Special key</td></tr>
      <tr><td>NUMPAD7</td><td>\uE021</td><td>Special key</td></tr>
      <tr><td>NUMPAD8</td><td>\uE022</td><td>Special key</td></tr>
      <tr><td>NUMPAD9</td><td>\uE023</td><td>Special key</td></tr>
      <tr><td>MULTIPLY</td><td>\uE024</td><td>Special key</td></tr>
      <tr><td>ADD</td><td>\uE025</td><td>Special key</td></tr>
      <tr><td>SEPARATOR</td><td>\uE026</td><td>Special key</td></tr>
      <tr><td>SUBTRACT</td><td>\uE027</td><td>Special key</td></tr>
      <tr><td>DECIMAL</td><td>\uE028</td><td>Special key</td></tr>
      <tr><td>DIVIDE</td><td>\uE029</td><td>Special key</td></tr>
      <tr><td>F1</td><td>\uE031</td><td>Special key</td></tr>
      <tr><td>F2</td><td>\uE032</td><td>Special key</td></tr>
      <tr><td>F3</td><td>\uE033</td><td>Special key</td></tr>
      <tr><td>F4</td><td>\uE034</td><td>Special key</td></tr>
      <tr><td>F5</td><td>\uE035</td><td>Special key</td></tr>
      <tr><td>F6</td><td>\uE036</td><td>Special key</td></tr>
      <tr><td>F7</td><td>\uE037</td><td>Special key</td></tr>
      <tr><td>F8</td><td>\uE038</td><td>Special key</td></tr>
      <tr><td>F9</td><td>\uE039</td><td>Special key</td></tr>
      <tr><td>F10</td><td>\uE03A</td><td>Special key</td></tr>
      <tr><td>F11</td><td>\uE03B</td><td>Special key</td></tr>
      <tr><td>F12</td><td>\uE03C</td><td>Special key</td></tr>
      <tr><td>META</td><td>\uE03D</td><td>Special key</td></tr>
      <tr><td>COMMAND</td><td>\uE03D</td><td>Special key</td></tr>
      <tr><td>ZENKAKU_HANKAKU</td><td>\uE040</td><td>Special key</td></tr>
    </table>
    <p>The keys considered upper-case symbols are either defined by the current keyboard locale or are derived from the US 104 keys Windows keyboard layout, which are:
    <ul>
      <li>A - Z</li>
      <li>!$^*()+{}:?|~@#%_\" &amp; &lt; &gt;</li>
    </ul>
    <p>When the user input is emulated natively (see note below), the implementation SHOULD use the current keyboard locale to determine which symbols are upper case. In all other cases, the implementation MUST use the US 104 key Windows keyboard layout to determine those symbols.</p>
    <p>The state of the physical keyboard MUST NOT affect emulated user input.</p>
    <h3>Internationalized input</h3>
    <p>Non-latin symbols: TBD</p>
    <p>Complex scripts using Input Method Editor (IME): TBD</p>
    </section> <!-- typing -->
    </section> <!-- high-level APIs -->
</section>
