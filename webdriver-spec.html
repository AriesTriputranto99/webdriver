<!DOCTYPE html>
<html>
  <head>
    <title>WebDriver</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!-- 
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "webdriver",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://dev.w3.org/2009/dap/ReSpec.js/documentation.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css"],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Simon Stewart", url: "https://plus.google.com/104565969450039850531/posts",
                company: "Google", companyURL: "http://www.google.com/" },
              { name: "David Burns", url: "http://www.theautomatedtester.co.uk/",
                company: "Mozilla", companyURL: "http://www.mozilla.org/" },
          ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],
          
          // name of the WG
          wg:           "Browser Testing and Tools Working Group",
          
          // URI of the public WG page
          wgURI:        "http://www.w3.org/2011/08/browser-testing-charter.html",
          
          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-test-infra",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
      };
    </script>
  </head>
  <body>

<section id='abstract'>
<p>This specification defines the WebDriver API, a platform-and language-neutral interface that allows programs or scripts to introspect into, and control the behaviour of, a web browser. The WebDriver API is primarily intended to allow developers to write tests that automate a browser from a separate controlling process, but may also be implemented in such a way as to allow in-browser scripts to control a (separate?) browser.</p>

<p>The WebDriver API is defined by a set of interfaces to discover and manipulate DOM elements on a page, and to control the behaviour of the containing browser.</p>

<p>This specification also includes a non-normative reference serialisation (to JSON) of the interface's invocations and responses that may be useful for browser vendors.</p>
</section>
<section>
  <h2>Introduction</h2>
  <p>The WebDriver API aims to provide a synchronous API that can be used for a variety of use cases, though
  it is primarily designed to support automated testing of web apps.</p>
  <section>
    <h3>Intended Audience</h3>
    <p>This specification is intended for implementors of the WebDriver API. It is not intended as light bed
    time reading.</p>
  </section>
  <section>
    <h3>Relationship of WebDriver API and Existing Specifications</h3>
    <p>Where possible and appropriate, the WebDriver API references existing specifications. For example, the
    list of boolean attributes for elements is drawn from the 
    <a href="http://dev.w3.org/html5/spec/Overview.html">HTML5 specification</a>. When references are made, this
    specification will link to the relevant sections.</p>
  </section>
  
  <section>
    <h3>Naming the Two Sides of the API</h3>
    
    <p>The WebDriver API can be thought of as a client/server process. However, implementation details can mean that this terminology becomes confusing. For this reason, the two sides of the API are called the "local" and the "remote" ends.</p>
    <dl>
      <dt>Local</dt>
      <dd>The user-facing API. Command objects are sent and Response objects are consumed by the local end of the WebDriver API.</dd>
      
      <dt>Remote</dt>
      <dd>The implementation of the user-facing API. Command objects are consumed and Response objects are sent by the remote end of the WebDriver API.</dd>
      
    </dl>
    
    <p>There is no requirement that the local and remote ends be in different processes.</p>
  </section>
</section>
<section>
  <h2>Commands and Responses</h2>
  <p>The WebDriver API is designed to be used both in-process and out-of-process. The IDL listed in Appendix
  XXXX SHOULD be used as the basis for the user-facing API. When used out-of-process, the WebDriver API
  defines command/repsonse objects that MUST be used. How these are encoded and transmitted between the browser being
  automated and the user of the API is left undefined, but a non-normative implementation of this as JSON over HTTP is
  given in appendix XXXX.</p>
  <section>
    <h3>Command</h3>
    <p>A command represents a call to the remote end of the WebDriver API.</p>
    <dl class="idl" title="interface Command">
      <dt>attribute string sessionId</dt>
      <dd>A reference to the session to which this command is associated.</dd>
      <dt>attribute string name</dt>
      <dd>The name of the command to execute</dd>
      <!-- TODO: This should be a Dictionary or Map, not an object -->
      <dt>attribute object parameters</dt>
      <dd>A map of the named parameters to an object representing its value.</dd>
    </dl>
  </section>
  <section>
    <h3>Response</h3>
    <p>A response represents the value returned from remote end of the WebDriver API.</p>
    <dl class="idl" title="interface Response">
      <dt>readonly attribute string sessionId</dt>
      <dd>A reference to the session to which this command is associated.</dd>
      <dt>readonly attribute integer status</dt>
      <dd>The status code representing the success or failure of the method. Anything other than 0 indicates a failure
      of some kind</dd>
      <dt>readonly attribute object value</dt>
      <dd>The return value of the method call. It's type is determined by the <code>Command</code> that has been executed. In the specification, each command definition will make clear what the expected return type is.</dd>
    </dl>
  </section>
  
  <section>
    <h3>Processing Additional Fields on Commands and Responses</h3>
    
    <p>Any Command or Response MAY contain additional fields than those listed above. These fields MUST be maintained, unaltered by any intermediate processing nodes. There is no requirement to maintain the ordering of fields.</p>
    
    <div class="note">
      <p>This requirement exists to allow for extension of the protocol, and to allow implementors to decorate Commands and Responses with additional information, perhaps giving context to a series of messages. or providing security information.</p>
    </div>
  </section>
  
  <section>
    <h3>Error Codes</h3>
    <p>The WebDriver API indicates the success or failure of a command invocation via a status code on the 
    <code>Response</code>object. The following values are used and have the following meanings.</p>
    <!-- TODO: These values are derived from existing common usage. Do they need to be reconsidered? -->
    <table>
      <tr>
        <th>Status Code</th>
        <th>Summary</th>
        <th>Detail</th>
      </tr>
      <tr>
        <td>0</td>
        <td>Success</td>
        <td>The command executed successfully.</td>
      </tr>
      <tr>
        <td>7</td>
        <td>NoSuchElement</td>
        <td>An element could not be located on the page using the given search parameters.</td>
      </tr>
      <tr>
        <td>8</td>
        <td>NoSuchFrame</td>
        <td>A request to switch to a frame could not be satisfied because the frame could not be found.</td>
      </tr>
      <tr>
        <td>9</td>
        <td>UnknownCommand</td>
        <td>The requested resource could not be found, or a request was received using an HTTP method that is not
        supported by the mapped resource.</td>
      </tr>
      <tr>
        <td>10</td>
        <td>StaleElementReference</td>
        <td>An element command failed because the referenced element is no longer attached to the DOM.</td>
      </tr>
      <tr>
        <td>11</td>
        <td>ElementNotVisible</td>
        <td>An element command could not be completed because the element is not visible on the page.</td>
      </tr>
      <tr>
        <td>12</td>
        <td>InvalidElementState</td>
        <td>An element command could not be completed because the element is in an invalid state (e.g. attempting to
        click a disabled element).</td>
      </tr>
      <tr>
        <td>13</td>
        <td>UnknownError</td>
        <td>An unknown server-side error occurred while processing the command.</td>
      </tr>
      <tr>
        <td>15</td>
        <td>ElementIsNotSelectable</td>
        <td>An attempt was made to select an element that cannot be selected.</td>
      </tr>
      <tr>
        <td>17</td>
        <td>JavaScriptError</td>
        <td>An error occurred while executing user supplied !JavaScript.</td>
      </tr>
      <tr>
        <td>19</td>
        <td>XPathLookupError</td>
        <td>An error occurred while searching for an element by XPath.</td>
      </tr>
      <tr>
        <td>21</td>
        <td>Timeout</td>
        <td>An operation did not complete before its timeout expired.</td>
      </tr>
      <tr>
        <td>23</td>
        <td>NoSuchWindow</td>
        <td>A request to switch to a different window could not be satisfied because the window could not be
        found.</td>
      </tr>
      <tr>
        <td>24</td>
        <td>InvalidCookieDomain</td>
        <td>An illegal attempt was made to set a cookie under a different domain than the current page.</td>
      </tr>
      <tr>
        <td>25</td>
        <td>UnableToSetCookie</td>
        <td>A request to set a cookie's value could not be satisfied.</td>
      </tr>
      <tr>
        <td>26</td>
        <td>UnexpectedAlertOpen</td>
        <td>A modal dialog was open, blocking this operation</td>
      </tr>
      <tr>
        <td>27</td>
        <td>NoAlertOpenError</td>
        <td>An attempt was made to operate on a modal dialog when one was not open.</td>
      </tr>
      <tr>
        <td>28</td>
        <td>ScriptTimeout</td>
        <td>A script did not complete before its timeout expired.</td>
      </tr>
      <tr>
        <td>29</td>
        <td>InvalidElementCoordinates</td>
        <td>The coordinates provided to an interactions operation are invalid.</td>
      </tr>
      <tr>
        <td>30</td>
        <td>IMENotAvailable</td>
        <td>IME was not available.</td>
      </tr>
      <tr>
        <td>31</td>
        <td>IMEEngineActivationFailed</td>
        <td>An IME engine could not be started.</td>
      </tr>
      <tr>
        <td>32</td>
        <td>InvalidSelector</td>
        <td>Argument was an invalid selector (e.g. XPath/CSS).</td>
      </tr>
    </table>
  </section>
</section>
<section>
  <h2>Browser Capabilities</h2>
  <p>Different browsers support different levels of various specifications. For example, some support SVG or the CSS
  Selector API, but only browsers that implement HTML5 will support LocalStorage. The WebDriver API provides
  a mechanism to query the supported capabilities of a browser. Each broad area of functionality
  within the WebDriver API has an associated capability string. Whether a particular capability MUST or MAY
  be supported --- as well as fallback mechanisms for handling those cases where a capability is not supported --- is
  discussed where the capability string is defined.</p>
  
  <section>
    <h3>Capabilities</h3>
  <dl class="idl" title="interface Capabilities">
    <dt>readonly attribute object capabilities</dt>
    <dd>The underlying collection of capabilities, represented as a dictionary mapping strings to values which may be
    of type boolean, numerical or string.</dd>
    <dt>boolean has(string capabilityName)</dt>
    <dd>Queries the underlying <code>capabilities</code> to see whether the
    value is set. This will return true if the capabilities contain a key with
    the given <code>capabilityName</code> and the value of that key is defined.
    If the value is a boolean, this function will return that boolean value. If
    the value is "null", an empty string or a 0 then this method will return
    false.</dd>
    <dt>object get(string capabilityName)</dt>
    <dd>Get the value of the key matching capabilityName in the underlying<code>capabilities</code>or <code>null</code>if no value is defined.</dd>
  </dl>
  <p>A <code>Capabilities</code> instance MUST be immutable. If a mutable <code>Capabilities</code> instance is required, then the <code>MutableCapabilities</code> MUST be used instead.</p>
</section>
<section>
  <h3>MutableCapabilities</h3>
  <dl class="idl" title="interface MutableCapabilities : Capabilities">
    <dt>void set(string capabilityName, object value)</dt>
    <dd>Set the value of the given <code>capabilityName</code>to the given <code>value</code>. If the value is not a boolean, numerical type or a string, a <code>WebDriverException</code>should be thrown.</dd>
  </dl>
</section>
</section>
<section>
  <h2>Sessions</h2>
  <p>Non-normative summary: A session is equivalent to a single instantiation of a particular browser, including all
  child windows. The WebDriver API gives each session a UUID stored as a string that can be used to differentiate one
  session from another, allowing multiple browsers to be controlled on the same machine if needed, and allowing
  sessions to be routed via a multiplexer. This ID is sent with every 
  <code>Command</code>and returned with every 
  <code>Response</code>and is stored on the 
  <code>sessionId</code>field.</p>
  <section>
    <h3>Creating a Session</h3>
    <p>The process for successfully creating a session follows.</p>
    <ol>
      <li>The local end creates a new Capabilities or MutableCapabilities instance describing the desired capabilities
      for the session. The Capabilities object MAY be empty, but MUST be defined.</li>
      <li>The local end creates a new Command with the "name" being "newSession" and the "parameters" containing an
      entry named "desiredCapabilities" with the value set to the Capabilities instance from the previous step. The
      "sessionId" fields SHOULD be left empty.</li>
      <li>For an out of process WebDriver server, this Command is encoded and transmitted to the remote end point. For
      an in-process WebDriver server, a factory function or method is called.</li>
      <li>The remote end examines the Capabilities, and creates a new session matching as many of the Capabilities as
      possible. How the new session is created depends on the implementation of this specification. In the case of a
      browser automation framework, it is expected that a new instance of the browser is started if possible.</li>
      <li>The session must be assigned a UUID which MUST be unique for each session (by definition). Generating the UUID
      MAY occur before the session is created. If the Command object had the "sessionId" field set, this MAY be
      discarded in favour of the freshly generated UUID. Because of this, it is
      recommanded that UUID generation be done on the remote end.</li>
      <li>The remote end create a new Response object. 
      <ul>
        <li>The "sessionId" field is assigned the UUID associated with this session.</li>
        <li>The session is described by filling a Capabilities instance with keys matching the parts of this
        specification that can be fulfilled. This is assigned to the "value" field of the Response. This fields MUST
        be filled</li>
        <li>The "status" field is set to "0"</li>
      </ul></li>
      <li>The Response is transmitted or returned back to the local end.</li>
    </ol>
    <p>There is no requirement for the local end to validate that some or all of the fields sent on the Capabilities
    associated with the Command match those returned in the Response.</p>
    <section>
      <h3>Capability Names</h3>
      <p>The following keys are to be used in the Capabilities instances.</p>
      <dl>
        <dt>browserName</dt>
        <dd>The name of the desired browser as a string</dd>
        <dt>version</dt>
        <dd>The version number of the browser, given as a string</dd>
        <dt>platform</dt>
        <dd>The OS that the browser is running on, matching any of the platform names given below.</dd>
        <dt>platformVersion</dt>
        <dd>The version of the OS that the browser is running on as a string.</dd>
      </dl>

      <section>
        <h3>Platform Names</h3>
        <p>These are named in the style of enums in C-like languages.</p>
        <ul>
          <li>ANDROID</li>
          <li>LINUX</li>
          <li>MAC</li>
          <li>UNIX</li>
          <li>WINDOWS</li>
        </ul>
        <p>In addition "ANY" may be used to indicate the underlying OS is either unknown or does not matter.
        Implementors MAY add additional platform names.</p>

        <!-- TODO: Add section on comparing platforms -->

      </section>
    </section>
    <section>
      <h3>Error Handling</h3>
      <p>The following status codes will be returned by the "newSession" command. Please consult the table in the
      "commands" section for numerical values:</p>
      <dl>
        <dt>Success</dt>
        <dd>The session was successfully created. The "value" field of the Response contains a Capabilities object
        describing the session</dd>
        <dt>Timeout</dt>
        <dd>The new session could not be created within the time allowed for command execution on the remote end. This
        time MAY be infinite. The "value" field of the Response SHOULD contain a string explaining that a timeout has
        occurred, but it MAY be left empty or filled with the empty string.</dd>
        <dt>UnknownError</dt>
        <dd>An unhandled error of some sort has occurred. The "value" field of the Response contains a more detailed
        description of the error.</dd>
      </dl>
    </section>
    <section>
      <h3>Remote End Matching of Capabilities</h3>
      <p>This section is non-normative.</p>
      <p>The suggested order for comparing keys in the Capabilities instance when creating a session is:</p>
      <ol>
        <li>browserName</li>
        <li>version</li>
        <li>platform</li>
        <li>platformVersion</li>
      </ol>
      <p>For all comparisons, if the key is missing, that particular criteria shall not factor into the
      comparison.</p>
    </section>
  </section>
</section>
<section>
  <h2>Navigation</h2>
  
  <p>
  <p>get() and history navigation. The discussion of "get" will
  need to be pretty precise about when the method returns,
  including the common case of switching to "about:blank" when
  opening a new tab.</p>

  <p>This section will also need to deal with handling self-signed
  SSL certificates.</p>

  <p>WebDriver implementations MUST support navigating between
  domains.</p>

  <section>
    <h3>Detecting When to Proceed</h3>

    <p>This entire section is non-normative for now, and should be considered a
    placeholder for future discussion.</p>

    <p>Upon receiving a Command, the remote end SHOULD not execute that Command
    until the current frame has "loaded". This can be detected in a number of
    ways:</p>

    <dl>
      <dt>Conservative</dt>
      <dd>The remote end waits until all frames and iframes in the window
      containing an HTML document are at "document.readyState == 'complete'" and
      there are no outstanding HTTP requests, other than those caused by an
      XMLHTTPRequest. If a frame does not contain an HTML document, the remote
      end waits until all HTTP traffic to that frame is complete.</dd>

      <dt>Normal</dt>
      <dd>The remote ends waits until the current frame reaches
      "document.readyState == 'complete'" or there are no more outstanding
      network requests.</dd>

      <dt>Eager</dt>
      <dd>The remote end waits until the currrent frame reaches
      "document.readyState == 'interactive' || document.readyState ==
      'complete'" or there are no more outstanding network requests.</dd>
    </dl>

    <p>Unless the user specificies otherwise, the "Normal" page load detection
    mechanism must be used.</p>

  </section>
</section>
<section>
<h2>Controlling Windows</h2>

<section>
	<h2>Defining "window" and "frame"</h2>
	
	<p>Within this specification, a window equates to anything that would be referred to as "window.top" in javascript. Put another way, within this spec browser tabs are counted as separate windows.</p>

	<p><strong>TODO: define "frame"</strong></p>
</section>

<section>
	<h2>Window Handles</h2>
	
	<p>Each window has a "window handle" associated with it. This is an opaque string which is unique to the window. The suggested implementation is as a UUID. The "getWindowHandle" command can be used to obtain the window handle for the window that commands are currently acting upon:</p>
	
	<table>
		<tr>
			<td>Command Name</td>
			<td>getWindowHandle</td>
		</tr>
		<tr>
			<td>Parameters</td>
			<td>"sessionId" {string} The key that identifies which session this request is for.</td>
		</tr>
		<tr>
		    <td>Return Value</td>
		    <td>string</td>
		</tr>
	</table>
</section>

<section>
	<h2>Iterating Over Windows</h2>
	
	<table>
		<tr>
			<td>Command Name</td>
			<td>getWindowHandles</td>
		</tr>
		<tr>
			<td>Parameters</td>
			<td>"sessionId" {string} The key that identifies which session this request is for.</td>
		</tr>
		<tr>
		    <td>Return Value</td>
		    <td>Array.&lt;string&gt;</td>
		</tr>
	</table>
	
	<p>This array of returned strings MUST contain a handle for every window associated with the browser session and no others. In addition, at the time of collecting the window handles the javascript expression "window.top.closed" MUST evaluate to false.</p>
	    
	<p>The ordering of the keys is not defined, but SHOULD be determined by iterating over each top level browser window and returning the tabs within that window before iterating over the tabs of the next top level browser window. For example, in the diagram below, the window handles should be returned as the handles for: win1tab1, win1tab2, win2.</p>
	
	<img src="example_windows.png" alt="Two top level windows. The first window has two tabs, lablled win1tab1 and win1tab2. The second window has only one tab labelled win2"/>
</section>

<section>
    <h2>Closing Windows</h2>
    
    <table>
    	<tr>
    		<td>Command Name</td>
			<td>close</td>
    	</tr>
    	<tr>
			<td>Parameters</td>
    		<td>"sessionId" {string} The key that identifies which session this request is for.</td>
    	</tr>
    	<tr>
    	    <td>Return Value</td>
    		<td>None</td>
    	</tr>
    </table>
    
    <p>The close command closes the window that commands are currently being sent to. If this means that a call to get the list of window handles returns an empty list, then this close command MUST be the equivalent of calling "quit". In all other cases, control MUST be returned to the calling process once the window has been closed or an alert is displayed by the closing window.</p>
    
    <p>Once the window has closed, future commands MUST return an error NoSuchWindowException until a new window is selected for receiving commands.</p>
</section>

<section>
    <h2>Resizing and Positioning Windows</h2>
    
    <table>
    	<tr>
    		<td>Command Name</td>
			<td>setWindowSize</td>
    	</tr>
    	<tr>
			<td>Parameters</td>
    		<td>"sessionId" {string} The key that identifies which session this request is for.<br />
    		    "windowHandle" {string} The handle referring to the window to resize.<br/>
    		    "width" {number} The new window width.<br />
                "height" {number} The new window height.
    		</td>
    	</tr>
    	<tr>
    	    <td>Return Value</td>
    		<td>None</td>
    	</tr>
    	
    	<tr>
    		<td>Command Name</td>
			<td>getWindowSize</td>
    	</tr>
    	<tr>
			<td>Parameters</td>
    		<td>"sessionId" {string} The key that identifies which session this request is for.<br />
    		    "windowHandle" {string} The handle referring to the window to resize.
    		</td>
    	</tr>
    	<tr>
    	    <td>Return Value</td>
    		<td>An object with two keys:<br />
    		    "width" {number} The width of the specified window.</br />
                "height" {number} The height of the specified window.</br />    
    		</td>
    	</tr>
    </table>
    
    <p>Both of these commands accept the window handles returned by "getWindowHandles" and "getWindowHandle". In addition, the window handle may be "current", in which case the window that commands are currently being handled by MUST be acted upon.</p>
    
    <p>The "width" and "height" values refer to the "window.outerheight" and "window.outerwidth" properties. For those browsers that do not support these properties, these represent the height and width of the whole browser window including window chrome and window resizing borders/handles.</p>
</section>

<section>
    <h2>Scaling the Content of Windows</h2>
    
    <p>TODO</p>
</section>

</section>
<section>
<h2>Where Commands Are Handled</h2>
  
<p>Web applications can be composed of multiple windows and/or frames. For a normal user, the context in which an operation is performed is obvious: it's the window or frame that currently has OS focus and which has just received user input. The WebDriver API does not follow this convention. There is an expectation that many browsers using the WebDriver API may be used at the same time on the same machine. This section describes how WebDriver tracks which window or frame is currently the context in which commands are being executed.</p>
    
<section>
<h2>Default Content</h2>
<p>WebDriver's <def="default_content">default context</def> is determined by running the algorithm:</p>

<p>Start by assigning "window._top" to the variable "window", then:

<ol>
    <li>If "window" has a FRAMESET, use the first FRAME as "window" and return to step 1.</li>
    <li>If "window" has an IFRAME:
        <ol>
            <li>If the previous value of "window" did not have an IFRAME, use the IFRAME as "window" and return to step 1.</li>
            <li>If the previous value of "window" did have an IFRAME, the current value of "window" is the default content.</li>
        </ol>
    </li>
    <li>In all other cases the current value of "window" is the default content</li>
</ol>
    
</p>
</section>

<section>
<h2>Switching Windows</h2>

<table>
	<tr>
		<td>Command Name</td>
		<td>switchToWindow</td>
	</tr>
	<tr>
		<td>Parameters</td>
		<td>"sessionId" {string} The key that identifies which session this request is for.<br/>
		    "name" {string} The identifier used for a window.</td>
		</td>
	</tr>
	<tr>
	    <td>Return Value</td>
	    <td>None</td>
	</tr>
	<tr>
	    <td>Throws</td>
	    <td>NoSuchWindowException if no matching window can be found</td>
	</tr>
</table>

<p>The "switchToWindow" command is used to select which window should currently be accepting commands. In order to determine which window should be used for accepting commands, the "switchToWindow" command will iterate over all windows. For each window, the following will be compared --- in this order --- with the "name" parameter:
    
    <ol>
        <li>A window handle, obtained from "getWindowHandles" or "getWindowHandle".</li>
        <li>The window name, as defined when the window was opened (the value of "window.name")</li>
        <li>The "id" attribute of the window.</li>
    </ol>

If no windows match, then a "NoSuchWindowException" MUST be thrown, otherwise the "default content" of the first window to match will be selected for accepting commands.</p>

<p>When a new browser session is started by WebDriver and only a single window is present then the default content of that window becomes the "current" window. When more than one window is opened, the "current" window is undefined. Any commands that are executed at this point that require a window MUST throw an exception (<strong>TODO: Which exception? Ideally the same as if a window had just been closed</strong>). The correct way for a user to recover from this situation is to obtain the list of window handles and to "switch to" one of these.</p>

</section>

<section>
<h2>Switching Frames</h2>

<table>
	<tr>
		<td>Command Name</td>
		<td>switchToFrame</td>
	</tr>
	<tr>
		<td>Parameters</td>
		<td>"sessionId" {string} The key that identifies which session this request is for.<br/>
		    "id" {?(string|number|!WebElement=)} The identifier used for a window.</td>
		</td>
	</tr>
	<tr>
	    <td>Return Value</td>
	    <td>None</td>
	</tr>
	<tr>
	    <td>Throws</td>
	    <td>NoSuchFrameException if no matching frame can be found</td>
	</tr>
</table>

<p>The "switchToFrame" command is used to select which frame within a window should be used for handling future commands. All frame switching is taken from the current context from which commands are currently being handled. The "id" parameter can be one of a string, number of an element. WebDriver implementations MUST determine which frame to select using the following algorithm:

<ol>
    <li>If the "id" is a number the current context is set to the equivalent of the JS expression "window.frames[n]" where "n" is the number and "window" is the DOM window represented by the current context.</li>
    <li>If the "id" is a string:
        <ol>
            <li>If the value is "_top", the current context is set to the equivalent of "window._top".</li>
            <li>If the JS expression "window.frames[id]" evaluated in the current context returns a window, where "id" is the value of the the "id" parameter, the current context is set to that.</li>
            <li>Otherwise for each value of "window.frames" (referred to as "window"):
                <ol>
                    <li>If "window" has a "name" property or attribute equal to the "id" parameter, this becomes the current context.</li>
                    <li>If "window" has an "id" property or attribute equal to the "id" parameter, this becomes the current context.</li>
                </ol>
            </li>
        </ol>
    </li>
    <li>If the "id" represents a WebElement, and the corresponding DOM element represents a FRAME or an IFRAME, and the WebElement is part of the current context, the "window" property of that DOM element becomes the current context.</li>
</ol>

In all cases if no match is made a "NoSuchFrameException" MUST be thrown.</p>

</section>

</section><section>
  <!-- TODO(simon): identify a better location for this -->
  <h2>Running Without Window Focus</h2>
  <p>All browsers must comply with the <a
    href="http://www.w3.org/TR/html5/editing.html#focus">focus</a> section of
  the [[!HTML5]] spec. In particular, the requirement that the element within a top-level browsing
  context be independent of whether or not the top-level browsing context itself
  has system focus MUST be followed.</p>

  <p class="note">This requirement is put in place to allow efficient machine
  utilization when using the WebDriver API to control several browsers
  independently on the same desktop</p>
</section>
<section>
  <h2>Elements</h2>
  <p>One of the key abstractions of the WebDriver API is the 
  <code>WebElement</code> interface. Each instance of this interface represents an 
  <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-745549614">Element</a>as defined in the
  [[!DOM-LEVEL-3-CORE]] specification. Because the WebDriver API is designed to allow users to interact with apps as if
  they were actual users, the capabilities offered by the 
  <code>WebElement</code> interface are somewhat different from those offered by the DOM Element interface.</p>

  <p>Each WebElement instance must have an ID, which is distinct from the value
  of the DOM Element's "id" property. The ID for every WebElement representing the same
  underlying DOM Element must be the same. The IDs used to refer to different
  underlying DOM Elements must be unique.</p>

  <div class="note">
    <p>This requirement around WebElement IDs allows for efficient equality
    checks when the WebDriver API is being used out of process.</p>
  </div>

  <p>This section of the specification covers finding elements. Later sections deal with querying and interacting with
  these located elements. The primary interface used by the WebDriver API for locating elements is the 
  <code>SearchContext</code>.</p>
  <section>
    <h2>Lists of WebElements</h2>
    
    <p>The primary grouping of <code>WebElement</code> instances is the WebElementList:</p>
    
    <dl class="idl" title="interface WebElementList">
      <dt>readonly attribute unsigned long length</dt>
      <dd>The number of <code>WebElement</code> instances represented by this list.</dd>
      <dt>getter WebElement item(in unsigned long index)</dt>
      <dd>Retrieve the <code>WebElement</code> at the given 0-based index in the collection. If there is no WebElement at this location, <code>null</code> must be returned.</dd>
    </dl>
    
    <div class="note">
      <p>Implementations of this interface in other languages MAY implement this as an indexed, ordered collection native to that language. For example, in Python the WebElementList might be implemented as an native "list". In C# or Java, a "List&lt;WebElement&gt;" would be an acceptable implementation. In this case, the WebElementList interface is optional, and the operations for determining length and returning WebElements may be replaced with native accessors.</p>
    </div>

    <p>A reference to an WebElement is obtained via a SearchContext. The key
    interfaces are:</p>
  </section>
  <section>
    <dl class="idl" title="interface Locator">
      <dt>readonly attribute DOMString strategy</dt>
      <dd>The name of the strategy that should be used to locate elements.</dd>
      <dt>readonly attribute DOMString value</dt>
      <dd>The value to pass to the element finding strategy</dd>
    </dl>
  </section>
  <section>
    <dl class="idl" title="interface SeachContext">
      <dt>caller getter WebElementList findElements(in Locator locator)</dt>
      <dd></dd>
      <dt>called getter WebElement findElement(in Locator locator)</dt>
      <dd></dd>
    </dl>
  </section>

  <section>
    <h2>Element Location Strategies</h2>
    <section>
      <h2>XPath</h2>
      <p>All WebDriver implementations MUST support finding elements by XPath 1.0 [[!XPATH]] with the <a href="http://dev.w3.org/html5/spec/Overview.html#interactions-with-xpath-and-xslt">edits from section 3.3</a> of the [[!HTML5]] specification made. If no native support is present in the browser, a pure JS implementation MAY be used. When called, the returned values MUST be equivalent of calling "<a href="http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-evaluate">evaluate</a>" function from the DOM Level 3 XPath spec [[DOM-LEVEL-3-XPATH]] with the result type set to "<a href="http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-ORDERED-NODE-SNAPSHOT-TYPE">ORDERED_NODE_SNAPSHOT_TYPE</a> (7).</p>
    </section>
    <section>
    <h2>ECMAScript</h2>
    <p>Finding elements by ecmascript is covered in the ecmascript part of this spec</p></section>
    <section>
      <h2>CSS Selectors</h2>
        <tr>
          <th>Capability Name</th>
          <th>Type</th>
        </tr>
        <tr>
          <td>cssSelectorsEnabled</td>
          <td>boolean</td>
        </tr>
      </table>
      <p>If a browser supports the 
      <a href="http://dev.w3.org/2006/webapi/selectors-api/">CSS Selectors API</a>it MUST support locating elements by
      CSS Selector. If the browser does not support the browser CSS Selector spec it MAY chose to implement locating
      by this mechanism.</p>
    </section>
    <section>
      <h2>Element ID</h2>
      <p>This strategy MUST be supported by all WebDriver implementations.</p>
      <p>The HTML5 specification ([[!HTML5]]) states that <a href="http://www.w3.org/TR/html5/elements.html#the-id-attribute">element IDs must be unique within their home subtree</a>. Sadly, this uniqueness requirement is not always met. Consequently, this strategy is equally valid for finding a single element, or groups of elements. In the case of finding a single WebElement, this MUST be functionally identical to a call to "<a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-getElBId">document.getElementById()</a>" from the Web DOM Core specification ([[!DOM-LEVEL-3-CORE]]). When finding multiple elements, this is equivalent to an XPath query of "<tt>//*[@id = 'value']</tt>" where "value" is the ID being searched for with all "'" characters being properly escaped..</p>
    </section>
    <section>
      <h2>Link Text</h2>
      <p>This strategy MUST be supported by all WebDriver implementations. </p>
      <p>The following algorithm MUST be used:</p>
      <ol>
        <li>WebDriver will need to look up all of the A elements on the page. The lookup SHOULD be done using 
          <a href="http://dev.w3.org/2006/webapi/selectors-api/">CSS Selectors API</a>
            but MAY use "<a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-A6C9094">document.getElementsByTagName()</a>" 
            from the Web DOM Core specification ([[!DOM-LEVEL-3-CORE]]). </li>
        <li>The value of getElementText MUST match with case sensitive of the search term passed in</li>
        <li>Compare the visibility of the element and return the element if and only if that matches the visible text</li>
      </ol>
    </section>
    <section>
      <h2>Partial Link Text</h2>
      <p>This strategy MUST be supported by all WebDriver implementations.</p>
      <p>The following algorithm MUST be used:</p>
      <ol>
        <li>Look up all of the A elements on the page. The lookup SHOULD be done using 
          <a href="http://dev.w3.org/2006/webapi/selectors-api/">CSS Selectors API</a>
            but MAY use "<a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-A6C9094">document.getElementsByTagName()</a>" 
            from the Web DOM Core specification ([[!DOM-LEVEL-3-CORE]]). </li>
        <li>The search term MUST match case sensitive a subsection of the value of getElementText</li>
      </ol>
    </section>
    <section>
      <h2>ARIA</h2>
      <p></p>
    </section>
  </section>
</section>
<section>
<h2>Reading Element State</h2>
  <p></p>
  <section>
    <h2>Determining Visibility</h2>
      <p>The following algorithm is used to determine if an element has been displayed.</p>
      <ul>
        <li>The element has a height and width greater than 0px.</li>
        <li>The element, or an ancestor, must not be visible if that element, or its ancestor,
        is hidden or has a display property that is none.</li>
        <li>OPTIONs and OPTGROUP are treated as special cases, they are considered shown if and
        only if the enclosing select element is visible.</li>
        <li>MAP elements are shown if and only if the image it uses is visible. Areas within
        a map are shown if the enclosing MAP is visible.</li>
        <li>Any INPUT elements of "type=hidden" are not visible</li>
        <li>Any NOSCRIPT elements will not be visible</li>
        <li>The element MUST be hidden if their ancestor has a fixed size AND has the
        CSS style of "overflow:hidden" and the element's location is not within the fixed
        size of the parent</li>
      </ul>
    <table>
      <tr>
        <td>Command Name</td>
        <td>isDisplayed</td>
      </tr>
      <tr>
        <td>Parameters</td>
        <td>"sessionId" {string} The key that identifies which session this request is for.<br/>
            "id" {string} The ID of the WebElement on which to operate.
        </td>
      </tr>
      <tr>
        <td>Return Value</td>
        <td>{boolean} Whether the element is displayed or not</td>
      </tr>
      <tr>
        <td>Throws</td>
        <td>StaleElementReferenceException if the element referenced is no longer attached to
          the DOM</td>
      </tr>
    </table>
  </section>
  <section>
    <h2>Reading Attributes and Properties</h2>

<p>Although the [[!HTML5]] spec is very clear about the difference between the properties and attributes of a DOM element, users are frequently confused between the two. Because of this, the WebDriver API offers a single command ("getElementAttribute") which covers the case of returning both the value of a DOM element's property or attribute. If a user wishes to refer specifically to an attribute or a property, they should evaluate Javascript in order to be unambiguous.</p>

<p>In order to implement the "getElementAttribute" command, a series of sub functions are needed. These are detailed below.</p>

<section>
<h2>Reading an Attribute</h2>
    
<p>Reading an attribute is equivalent to calling the Javascript "getAttribute" function on an element, with the following exceptions:
<ul>
    <li>The "style" attribute MUST return the same value as if the "style" property was requested (see below).</li>
    <li>If the attribute represents a boolean and the attribute name is listed below the null value MUST be returned if the attribute is false, otherwise the string 'true' MUST be returned.</li>
    <li>If the attribute name represents a boolean and the attribute is not listed below, the null value SHOULD be returned if the attribute is false, otherwise the string 'true' SHOULD be returned.</li>
</ul>
</p>
<p>The following are considered boolean attributes:
<ul>
   <li>async</li>
    <li>autofocus</li>
    <li>autoplay</li>
    <li>checked</li>
    <li>compact</li>
    <li>complete</li>
    <li>controls</li>
    <li>declare</li>
    <li>defaultchecked</li>
    <li>defaultselected</li>
    <li>defer</li>
    <li>disabled</li>
    <li>draggable</li>
    <li>ended</li>
    <li>formnovalidate</li>
    <li>hidden</li>
    <li>indeterminate</li>
    <li>iscontenteditable</li>
    <li>ismap</li>
    <li>itemscope</li>
    <li>loop</li>
    <li>multiple</li>
    <li>muted</li>
    <li>nohref</li>
    <li>noresize</li>
    <li>noshade</li>
    <li>novalidate</li>
    <li>nowrap</li>
    <li>open</li>
    <li>paused</li>
    <li>pubdate</li>
    <li>readonly</li>
    <li>required</li>
    <li>reversed</li>
    <li>scoped</li>
    <li>seamless</li>
    <li>seeking</li>
    <li>selected</li>
    <li>spellcheck</li>
    <li>truespeed</li>
    <li>willvalidate</li>
</ul>
</p>
</section>

<section>
    <h2>Reading a Property</h2>

<p>A DOM element property may be read using the equivalent of the Javascript "return element['propertyName']" with the null value being returned when there is no match. The following exceptions MUST be made:
        
    <ul>
        <li>For a property that is marked as boolean in [[!HTML5]] the boolean value "true" or "false" MUST be returned. If a document is using HTML5, then the section on <a href="http://www.w3.org/TR/html5/Overview.html#boolean-attributes">boolean attributes</a> from the [[!HTML5]] spec MUST be followed. If the document is using a prior version of HTML, then "false" is returned iff the value of the property is equal to undefined.</li>
        <li>If the element is an OPTION element and the property name is "value" and there is no "value" attribute, then the text content of the OPTION element MUST be returned, in accordance with [[!HTML401]] spec, specifically the section on <a href="http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-value-OPTION">pre-selected options</a>. The text content MUST be the result of calling the "getElementText" command on the OPTION element.</li>
    </ul>
</p>
    
<p>If no property matches and the desired property name is in the table below, a WebDriver implementation MUST search for the aliased property before returning null.</p>

    <table>
        <tr>
            <th>Original property name</th>
            <th>Aliased property name</th>
        </tr>
        <tr>
            <td>class</td>
            <td>className</td>
        </tr>
        <tr>
            <td>readaonly</td>
            <td>readOnly</td>
        </tr>
    </table>

<p class="note">These aliases provide the commonly used names for element properties.</p>

<section>
<h2>The "style" Property</h2>

<p>The "style" property MUST be <a href="http://dev.w3.org/csswg/cssom/#serialize-a-css-rule">serialized as defined</a> in the [[!CSSOM]] spec.</p> Consequently, it SHOULD be equivalent to obtaining the "cssText" property, with the additional constraint that the same value MUST be returned after a round trip through "executeScript". That is, the following pseudo-code MUST be true (where "driver" is a WebDriver instance, and "element" is a WebElement):</p>

<pre class="code">
var style = element.getAttribute('style');
driver.executeScript('arguments[0].style = arguments[1]', element, style);
var recovered = element.getAttribute('style');
assertEquals(style, recovered);
</pre>

</section>
</section>
      
<section>
<a name="selectable"><h2>Determining Whether a WebElement Is Selected</h2></a>
    
<p>WebDriver determines whether a WebElement is selected using the following algorithm:

<ol>
    <li><a href="is_selectable"></a>If the item is not "selectable", the WebElement is not selected. A selectable element is either an OPTION element or an INPUT element of type "checkbox" or "radio".</li> 
    <li>If the WebElement represents an INPUT element, call the "getProperty" method described above looking for the "checked" property. This indicates whether the element is selected.</li>
    <li>Otherwise, call the "getProperty" method described above looking for the "selected" property. This indicates whether the element is selected.</li>
</ol>

</p>    
</section>

<section>
<h2>The "getElementAttribute" Command</h2>
<table>
	<tr>
		<td>Command Name</td>
		<td>getElementAttribute</td>
	</tr>
	<tr>
		<td>Parameters</td>
		<td>"sessionId" {string} The key that identifies which session this request is for.<br/>
		    "id" {string} The ID of the WebElement on which to operate.</br>
		    "name" {string} The name of the property of attribute to return.</td>
		</td>
	</tr>
	<tr>
	    <td>Return Value</td>
	    <td>{string|null}</td>
	</tr>
	<tr>
	    <td>Throws</td>
	    <td>StaleElementException If the element is no longer attached to the DOM.</td>
	</tr>
</table>

<p>The "getElementAttribute" command depends on the functions described above. The algorithm to use is:

<ol>
    <li>Examine the combination of WebElement tag name and the attribute name to determine whether the return value is expected to be a URL.</li>
    <li>If the combination is one that expects a URL:
        <ol>
            <li>Get the named attribute using the algorithm described above.</li>
            <li>If there is a value, return the named property using the algorithm described above.</li>
            <li>Otherwise, return null.
        </ol>
    </li>
    <li>If the named attribute case insensitively matches "selected" or "checked" and the WebElement is selectable (as detailed in <a href="#is_selectable">the first bullet point of determining whether a WebElement is selected</a>), get the value determined by that algorithm. Return the string "true" if the result is true, or the null value if false.</li>
    <li>Get the value of the named property using the algorithm above.</li>
    <li>If the returned value is defined, not null and not an object return the value coerced into a string.</li>
    <li>Get the value of the named attribute using the algorithm above.</li>
    <li>If the value is defined and not null, return the value coerced into a string.</li>
    <li>Otherwise return null.</li>
</ol>
</p>

<p>The following combination of WebElement tag names and values for "name" are considered to return a URL value:
    <strong>TODO: This doesn't feel like an exhaustive list</strong>

<table>
    <tr>
        <th>Tag name</th>
        <th>"name" value</th>
    </tr>
    <tr>
        <td>A</td>
        <td>href</td>
    </tr>
    <tr>
        <td>IMG</td>
        <td>src</td>
    </tr>
</table>
    
</p>

    </section>
</section>
</section>
<section>
  <h2>Executing Ecmascript</h2>
  <p>This entire section is currently non-normative</p>
    <div class="note">
      <p>Open questions: What happens if a user's JS triggers a modal dialog?
      Blocking seems like a reasonable idea, but there is an assumption that
      WebDriver is not threadsafe.
      
      What happens to unhandled JS errors? Caused by a user's JS? Caused by JS
      on a page? How does a user of the API obtain the list of errors? Is that
      list cleared upon read?
    </div>
  <section>
  <h2>Synchronous Javascript Execution</h2>
  <p></p>
  </section>
  <section>
    <h2>ASynchronous Javascript Execution</h2>
    <p></p>
  </section>
  <section>
    <h2>Reporting Errors</h2>
    <p></p>
  </section>
</section>
<section> 
  <h2>Cookies</h2>
  <p></p>
</section>
<section>
  <h2>Timeouts</h2>
  <p>This section describes how timeouts and implicit waits are handled within WebDriver</p>
  <section>
    <p>The "timeouts" command is used to set the value of a timeout that a command can execute
     for.</p> 
    <table>
      <tr>
        <td>Command Name</td>
        <td>timeouts</td>
      </tr>
      <tr>
        <td>Parameters</td>
        <td>"sessionId" {string} The key that identifies which session this request is for.</br>
            "type" {string} The type of operation to set the timeout for. Valid values are: "implicit", "page load", "script"</br>
            "ms" - {number} The amount of time, in milliseconds, that time-limited commands are permitted to run.
        </td>
      </tr>
      <tr>
        <td>Return Value</td>
        <td>None</td>
      </tr>
      <tr>
        <td>Throws</td>
        <td>None</td>
      </tr>
    </table>
    <ul>
      <li>implicit - Set the amount of time the driver should wait when searching for elements. When searching for a single element, the driver should poll the page until an element is found or the timeout expires, whichever occurs first. When searching for multiple elements, the driver should poll the page until at least one element is found or the timeout expires, at which point it should return an empty list.</br>
      If this command is never sent, the driver should default to an implicit wait of 0ms.</li>
      <li>page load -<strong>TODO(David, Simon)  fill me in</strong> </li>
      <li>script - Set the amount of time the driver should wait when scripts are loading on to the page. </li>
    </ul>
  </section>
</section>
<section>
  <h2>User Input</h2>
    <p>There are two ways to interact with a elements: Directly or indirectly.
    Direct interaction with elements is sending interaction commands directly to
    an element. In this kind of interaction, the implementation of this
    specification should take additional steps to ensure the interaction could
    happen as the user intended. Indirect interaction is more versatile by not
    tying a user-interaction to an element. Instead, these interactions are
    based on mouse position and the currently active element.</p>
    <section>
    <h2>Interaction directly with elements</h2>
    <section>
    <h2>Clicking</h2>
    <dl class="idl" title="interface WebElement">
      <dt>void click()</dt>
      <dd>Clicks in the middle of the <code>WebElement</code> instance. The
      middle of the element is defined as the middle of the box returned by
      calling <a href="http://www.w3.org/TR/cssom-view/#the-getclientrects-and-getboundingclientrect-methods">getBoundingClientRect</a> on the underlying DOM Element, according to the [[!CSSOM-VIEW]] spec. If the element is outside the <a href="http://www.w3.org/TR/CSS2/visuren.html#viewport">viewport</a> (according to the [[!CSS2]] spec), the implementation should bring the element into view first. The implementation MAY invoke scrollIntoView on the underlying DOM Element.</dd>
    </dl>
    </section>
    <section>
    <h2>Typing keys</h2>
    </section>
    </section>

    <p class="note">User input should be emulated natively</p>
    <section>
      <h2>High Level APIs: Clicking and Typing</h2>
      <p></p>
    </section>
    <section>
      <h2>Low Level APIs</h2>
      <p></p>
      <section>
        <h2>Mouse</h2>
        <p></p>
      </section>
      <section>
        <h2>Keyboard</h2>
        <p></p>
        <section>
          <h2>IME</h2>
          <p></p>
        </section>
      </section>
      <section>
        <h2>Touch</h2>
        <p></p>
      </section>
    </section>
</section>
<section>
  <h2>Modal Dialogs</h2>
    <p>This entire section should be considered non-normative</p>
    <p>The remote end MUST fail fast if any command is received while a modal
      dialog is open, unless that command handles the dialog.</p>
    <section>
      <h2>window.alert, prompt and confirm</h2>
      <p></p>
    </section>
    <section>
      <h2>Modal Windows</h2>
      <p></p>
    </section>
</section>
<section>
  <h2>Snapshots</h2>
  <p></p>
  <section>
    <h2>Screen</h2>
    <p></p>
  </section>
  <section>
    <h2>Current Window</h2>
    <p></p>
  </section>
  <section>
    <h2>Element</h2>
    <p></p>
  </section>
</section>
<section>
  <h2>Handling non-HTML Content</h2>
  <p></p>
</section>
  <section>
    <h2>Extending the Protocol</h2>
    <p></p>
  </section>

<section class='appendix'>
  <h2>Command Summary</h2>
  
  <p>This is an exhaustive list of the commands listed in this specification.</p>
</section>    <section class='appendix'>
      <h2>Command Format</h2>
      <p>This is essentially the content at the start of the json wire protocol</p>
    </section>

    <section class='appendix'>
      <h2>Thread Safety</h2>
      <p></p>
    </section>

    <section class='appendix'>
      <h2>Logging</h2>
      <p></p>
    </section>

    <section class='appendix'>
      <h2>Mapping to HTTP and JSON</h2>
      <p></p>
    </section>

    <section class='appendix'>
      <h2>Acknowledgements</h2>
      <p>
        Many thanks to Robin Berjon for making our lives so much easier with his
        cool tool. Thanks to Jason Leyba and Malcolm Rowe for proof reading and suggesting areas for improvement.
      </p>
    </section>
  </body>
</html>
