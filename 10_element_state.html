<section>
<h2>Reading Element State</h2>
  <section>
    <h2>Determining Visibility</h2>
      <p>The following algorithm is used to determine if an element has been displayed.</p>
      <ul>
        <li>The element has a height and width greater than 0px.</li>
        <li>The element MUST not be visible if that element, or any of its ancestors,
        is hidden or has a display property that is none.</li>
        <li>OPTIONs and OPTGROUP are treated as special cases, they are considered shown if and
        only if the enclosing select element is visible.</li>
        <li>MAP elements are shown if and only if the image it uses is visible. Areas within
        a map are shown if the enclosing MAP is visible.</li>
        <li>Any INPUT elements of "type=hidden" are not visible</li>
        <li>Any NOSCRIPT elements MUST not be visible if Javascript is enabled.</li>
        <li>The element MUST be not be visible if any ancestor in the element's transitive closure of <a href="http://www.w3.org/TR/cssom-view/#offset-attributes">offsetParents</a> has a fixed size, and has the CSS style of "overflow:hidden", and the element's location is not within the fixed size of the parent</li>
      </ul>
    <table>
      <tr>
        <td>Command Name</td>
        <td>isDisplayed</td>
      </tr>
      <tr>
        <td>Parameters</td>
        <td>"id" {string} The ID of the WebElement on which to operate.
        </td>
      </tr>
      <tr>
        <td>Return Value</td>
        <td>{boolean} Whether the element is displayed.</td>
      </tr>
      <tr>
        <td>Errors</td>
        <td>StaleElementReferenceException if the element referenced is no longer attached to
          the DOM</td>
      </tr>
    </table>
  </section>
  <section>
    <h2>Determining Whether a WebElement Is Selected</h2>
    <p>WebDriver determines whether a WebElement is selected using the following algorithm:
      <ol>
          <li><a href="is_selectable"></a>If the item is not "selectable", the WebElement is not selected. A selectable element is either an OPTION element or an INPUT element of type "checkbox" or "radio".</li> 
          <li>If the WebElement represents an INPUT element, call the "getProperty" method described above looking for the "checked" property. This indicates whether the element is selected.</li>
          <li>Otherwise, call the "getProperty" method described above looking for the "selected" property. This indicates whether the element is selected.</li>
      </ol>
    <table>
      <tr>
        <td>Command Name</td>
        <td>isSelected</td>
      </tr>
      <tr>
        <td>Parameters</td>
        <td>"id" {string} The ID of the WebElement on which to operate.
        </td>
      </tr>
      <tr>
        <td>Return Value</td>
        <td>{boolean} Whether the element is selected, according to the above algorithm.</td>
      </tr>
      <tr>
        <td>Errors</td>
        <td>StaleElementReferenceException if the element referenced is no longer attached to the DOM</td>
      </tr>
    </table>
  </section>
  <section>
    <h2>Reading Attributes and Properties</h2>
    <p>Although the [[!HTML5]] spec is very clear about the difference between the properties and attributes of a DOM element, users are frequently confused between the two. Because of this, the WebDriver API offers a single command ("getElementAttribute") which covers the case of returning both the value of a DOM element's property or attribute. If a user wishes to refer specifically to an attribute or a property, they should evaluate Javascript in order to be unambiguous. In this section, the "attribute" with name <code>name</code> shall refer to the result of calling the Javascript "getAttribute" function on the element, with the following exceptions:</p>
    <ul>
      <li>If, in the current rendering mode, the content attribute <code>name</code> reflects a boolean IDL attribute, as per <a href="http://www.whatwg.org/specs/web-apps/current-work/">the HTML specification</a>, the value MUST be the string 'true' if that IDL attribute's value is true or the null value if the IDL attribute's value is false.</li>
      <li>If the element is an OPTION element and <code>name</code> is "value" and there is no "value" attribute, then the text content of the OPTION element MUST be returned, in accordance with [[!HTML401]] spec, specifically the section on <a href="http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#adef-value-OPTION">pre-selected options</a>. The text content MUST be the result of calling the "getElementText" command on the OPTION element.</li>
      <li>If the element is selectable, and <code>name</code> is "selected", or the element is an INPUT element of type "checkbox" or "radio" and <code>name</code> is "checked", return the string 'true' if the element is selected, and the null value otherwise.</li>
      <li>If <code>name</code> is "style", the value returned MUST be <a href="http://dev.w3.org/csswg/cssom/#serialize-a-css-rule">serialized as defined</a> in the [[!CSSOM-VIEW]] spec. Notably, css property names MUST be cased the same as specified in in section 6.5.1 of the [[!CSSOM-VIEW]] spec.
        <ul>
          <li>Consequently, it SHOULD be equivalent to obtaining the "cssText" property, with the additional constraint that the same value MUST be returned after a round trip through "executeScript". That is, the following pseudo-code MUST be true (where "driver" is a WebDriver instance, and "element" is a WebElement):
<pre class="code">
var style = element.getAttribute('style');
driver.executeScript('arguments[0].style = arguments[1]', element, style);
var recovered = element.getAttribute('style');
assertEquals(style, recovered);
</pre>
          </li>
          <li>Color property values MUST be standardized to rgba format, matching the regular expression: <code>rgba\(\d+, \d+, \d+, (1|0(\.\d+)?)\)</code>.</li>
        </ul></li>
      <li>If the value is expected to be a URL (see the below table), return the property named <code>name</code>, i.e. a fully resolved URL:
        <strong>TODO: This doesn't feel like an exhaustive list</strong>
        <table>
            <tr>
                <th>Tag name</th>
                <th>"name" value</th>
            </tr>
            <tr>
                <td>A</td>
                <td>href</td>
            </tr>
            <tr>
                <td>IMG</td>
                <td>src</td>
            </tr>
        </table>
      </li>
      <li>If <code>name</code> is in the below table, and the above stages have not yielded a defined, non-null value, the value of the aliased attribute in the table below should be returned:
      <table>
        <tr>
          <th>Original property name</th>
          <th>Aliased property name</th>
        </tr>
        <tr>
          <td>class</td>
          <td>className</td>
        </tr>
        <tr>
          <td>readonly</td>
          <td>readOnly</td>
        </tr>
      </table></li>
    </ul>
    <p class="note">These aliases provide the commonly used names for element properties.</p>

    <table>
      <tr>
        <td>Command Name</td>
        <td>getElementAttribute</td>
      </tr>
      <tr>
        <td>Parameters</td>
        <td>"sessionId" {string} The key that identifies which session this request is for.<br>
            "id" {string} The ID of the WebElement on which to operate.<br>
            "name" {string} The name of the property of attribute to return.</td>
      </tr>
      <tr>
          <td>Return Value</td>
          <td>{string|null} The value returned by the above algorithm, coerced to a nullable string, or null if no value is defined.</td>
      </tr>
      <tr>
          <td>Errors</td>
          <td>StaleElementException If the element is no longer attached to the DOM.</td>
      </tr>
    </table>
  </section>
  <section>
   <h2>Rendering Text</h2>
   <p>All WebDriver implementations must support getting the <a href="#visibility">visible</a> text of a WebElement, with excess whitespace compressed.</p>
   
<p>The following definitions are used in this section:
    <dl>
        <dt id="text.whitespace">Whitespace</dt>
        <dd>Any text that matches the ECMAScript regular expression class <code>\s</code>.
        
        <dt id="text.whitespace-nbsp">Whitespace excluding non-breaking spaces</dt>
        <dd>Any text that matches the ECMAScript regular expression <code>[^\S\xa0]</code>
            
        <dt id="text.blocklevel">Block level element</dt>
        <dd>A block-level element is one which is not a table cell, and whose effective CSS display style is not in the set ['inline', 'inline-block', 'inline-table', 'none', 'table-cell', 'table-column', 'table-column-group']</dd>
        
        <dt id="text.horizontal">Horizontal whitespace characters</dt>
        <dd>Horizontal whitespace characters are defined by the ECMAScript regular expression <code>[\x20\t\u2028\u2029]</code>.</dd>
    </dl>

<p>The expected return value is roughly what a text-only browser such as Lynx would display. The algorithm for determining this text is as follows:</p>

<p>Let <code>lines</code> equal an empty array. Then:
<ol>  
    <li><span id="text.1">For</span> each <code>child</code> of node, at time of execution, in order:
        <ol>
            <li>Get whitespace, text-transform, and then, if <code>child</code> is:
                <ul>
                    <li>a node which is not <a href="#visibility">visible</a>, do nothing</li>
                    <li>a [[!DOM4]] <a href="http://www.w3.org/TR/2012/WD-dom-20120105/#interface-text">text node</a> let <code>text</code> equal the <code>nodeValue</code> property of <code>child</code>. Then:
                        <ol>
                            <li>Remove any zero-width spaces (\u200b), form feeds (\f) or vertical tab feeds (\v) from <code>text</code>.</li>
                            <li>Canonicalize any recognized single newline sequence in <code>text</code> to a single newline (greedily matching <code>(\r\n|\r|\n)</code> to a single \n)</li>
                            <li>If the parent's effective CSS whitespace style is 'normal' or 'nowrap' replace each newline (\n) in <code>text</code> with a single space character (\x20). If the parent's effective CSS whitespace style is 'pre' or 'pre-wrap' replace each <a href="#text.horizontal">horizontal whitespace character</a> with a non-breaking space character (\xa0). Otherwise replace each sequence of <a href="#text.horizontal">horizontal whitespace characters</a> except non-breaking spaces (\xa0) with a single space character</li>
                            <li>Apply the parent's effective CSS text-transform style as per the <a href="http://www.w3.org/TR/CSS21/text.html#propdef-text-transform">CSS 2.1 specification</a> ([[!CSS21]])</li>
                            <li>If <code>last(lines)</code> ends with a space character and <code>text</code> starts with a space character, trim the first character of <code>text</code>.</li>
                            <li>Append <code>text</code> to <code>last(lines)</code> in-place</li>
                        </ol>
                    </li>
                    <li>an element which is <a href="#visibility">visible</a>. If the element is a:
                        <ul>
                            <li>BR element: Push '' to <code>lines</code> and continue</li>
                            <li><a href="#text.blocklevel">Block-level</a> element and if <code>last(lines)</code> is not '', push '' to <code>lines</code>.</li>
                        </ul>
                    And then recurse depth-first to <a href="text.1">step 1</a> with <code>child</code> set to the current element</li>
                    <li>If element is a TD element, or the effective CSS display style is 'table-cell', and last(lines) is not '', and <code>last(lines)</code> does not end with whitespace append a single space character to <code>last(lines)</code> [Note: Most innerText implementations append a \t here]</li>
                    <li>If element is a block-level element: push '' to <code>lines</code></li>
                </ul>
            </li>
        </ol>
    </li>
    <li>For each line in <code>lines</code> trim any leading and trailing whitespace excluding <a href="text.whitespace-nbsp">non-breaking space characters</a>.</li>
    <li>Let <code>s</code> be <code>lines.join('\n')</code></li>
    <li>Trim any leading and trailing <a href="text.whitespace-nbsp">whitespace excluding non-breaking space characters</a> from <code>s</code>.</li>
    <li>Replace any non-breaking spaces (\xa0) with spaces (\x20) in <code>s</code>.</li>
    <li>Return <code>s</code>.</li>
</ol>

</section>
</section>
